> - **Json**       是一种非常重要的序列化/反序列化的方式
>
> ​      优点：直观，方便调试。
>
> ​      缺点：效率低
>
> - **google protobuf**    是二进制的方式序列化

```c++
//Linux  网络编程2    计算器的简易实现
#include "tcp_thread_srever.hpp"//服务器端
//请求 10 20+   响应30
//使用Json的方式进行序列化和反序列化
//{"num1" :10,   "num2" : 20,   "op0" : + ,}
///////////改进nums [10,20,30,40]
//{"result" : 30}
int main(){
	TcepThreadServer server;
	server.Strat("0.0.0.0", 9090, [](const std::string& req, std::string* resp)){
	//1.先将 req 进行反序列化
		Json::Reader reader;//表示一个Json数据
		Json::Value req_json;//把字符串转换成 Json::Value
		//Json::write  把Jason::Value 转成字符串
		reader.prse(req, req_json);
	//2.根据反序列化的结果，进行计算
		int  num1 = req_jsomn["[num1]"].asInt();
		int  num2 = req_jsomn["[num2]"].asInt();
/////////更复杂的操作 Json::Value& nums = req_jsomn["nums"];
		std::string op = req_json["op"].asString();
		int result = 0;
//////////////for(size_t i = 0li<nums.size();++i)
		if (op == "+"){
			result = num1 + num2;
		}///////////result += nums[(int)i].asInt();
		else if (op == "-"){
			result = num1 - num2;
		}//////////////result -= nums[(int)i].asInt();
		//3.需要把结果再序列化回一个字符串
		Json::FastWriter writer;
		Json::Value resp_jspn;
		resp_json["result"] = result;
		*
	});
	return 0;
}//用第三方库
/////////////////////////////////////////////yum  list | grep 
//////安装devel.  后缀的 
////ll  jsoncpp/
//#include <jsoncpp/json/json.h>



//client

int main()
{//1.创建一个tcp客户端
	TcpClient client;
	bool ret = Clinet.Connect("127.0.0.1", 9090);
	if (!ret)
	{
		printf("connect failed!\n");
		return 1;
	}
//2.循环从标准输入读入数据
	while (true){
		prinft("请输入2个操作数和一个操作符");
		fflush(stdout);
		int num1, num2;
		char op[10] = { 0 };
		scanf("%d %d %s", &num1, &num2, cp);
//3.根据用户输入的内容，构建一个Json对象
		Json::FastwWriter writer;//Fast 改成 stlye 输出结果格式会换行，，
		std::string req = writer.wirter(req_json);
		printf("req:%s\n", req.c_str);
//4.把Json对象序列化成一个字符串
//5.把字符串发送到服务器
//6.从服务器读取返回的结果
//7.服务器返回结果再进行Json解析
	}
}
```

## 应用层

### HTTP协议

```c++
void HttpProcess(const std::string& req, std::string* resp){
	//不管用户输入什么请求，都返回 hello world
	(void)req;
	
}
int main()
{
	TcpThreadServer server;
}
```



### 格式

#### 请求：

> - 1.首行（使用空格分隔）     
>
>   a.方法(GET/POST/PUT//DELETE/HEAD)  
>
>   b.url    c.http版本号.   HTTP/1.1（当前最常见的版本号）    3.0是最新版本
>
> - 2.头部信息(header)
>
>   包含了若干行   每行是一个键值对，键和值之间用：分割
>
> - 3.空行     
>
>   表示header的结束
>
> - 4.请求体（boday）   
>
>   空行后面的内容都是body，body是可选的，可以有也可以没有，一般来说GET请求不带body，POST/PUT请求带body

#### 响应：

> - 1.首行
>
>   a.版本号
>
>   b.状态码（200）
>
>   c.状态码的描述信息（OK）
>
> - 2.header
>
>   有若干行，每行是一个header（键值对）
>
>   键和值之间用
>
> - 3.空行
>
>   表示header
>
> - 4.body

出现概率极高的面试题：
**说HTTP协议种常见的方法？**

GET  POST

**两者的区别？？？**

GET 往往把参数放到 query_string中

POST  放到body

**常见的HTTP状态码有哪些，分别是啥含义？**

> - 200  OK         成功
>
> - 302 FOUND 重定向   /   303 See Other重定向
>
>   Location字段表示重定向到哪个 url上去
>
> - 403               用户没有权限
>
> - 404 Not Found   没有找到指定的资源
>
> - 502 Bad Gateway  服务器挂了
>
> - 504 Gateway Timeout 服务器响应超时

> - 1XX   接收的请求正在处理
> - 2XX  请求成功
> - 3XX  重定向，需要进行附加操作以完成请求
> - 4XX  客户端出现错误
> - 5XX   服务器出现错误

**fiddler抓包：**URL

俗称的“网站”就是URL

域名和IP是对应的，要访问还要知道端口号  默认的是80  或者 443？？

urlEncode编码工具，，   数据——>url

fiddler  抓包工具，，

### HTTP常见Header

> - Content-Type：描述了body部分数据格式是什么类型 text/html
> - Content-Length： Body的长度
> - User-Agent:  描述浏览器的消息和操作系统的信息 像手机端看到的页面并不是服务器根据UA来吐的一个单独的比较窄的页面，而实完全靠前端的技术来实现的（响应式编程）
> - referer：  当前页面是从哪个页面跳转过来的（查看链接的点击来源）流量劫持 HTPS 改善，，
> - Cookie： 是一个保存在浏览器端的字符串。字符串的含义是由程序员内部约定的，外部·的用户一般是看不懂的。最常见的内容是用户的身份信息（当我们登陆账号的时候，服务器就会返回一个身份信息字符串，浏览器垴村再coookie中）是浏览器存储数据的一种方式

**hw3school**：前端课。。。。。。。。。。。。。。HTML+ CSS +JavaScript

```c++
//如果使用虚拟机来搭建服务器，必须要西安关闭防火墙
//root service firewalld stop
//service firewalld status 查看状态
//service firewalld start 开启  是绿色
//爬虫程序，也需要输入理解http， 爬虫就是一个http客户端。改变ccookie标识，，
```

## 传输层

> 一个进程**可以**绑定多个端口号 socket几个就可以绑定几个
>
> 一个端口号能否被多个不同的进程绑定：  **通常情况下不可以**

### 端口号范围划分

> - 0 - 1023：知名端口号，HTTP,FTP,SSH等这些广位使用的应用层协议，他们的端口号都是固定的
> - 1024-65535：操作系统动态分配的段葵花，客户端程序的端口号，就是由操作系统整个范围分配的

为了使用方便，约定了一些常用的服务器固定的端口号  `cat /etc/services`可以查看

> - ssh服务器, 使用22端口
> - ftp服务器, 使用21端口
> - telnet服务器, 使用23端口
> - http服务器, 使用80端口
> - https服务器, 使用443

## UDP协议

UDP使用的是比较简单的CRC校验

unit16_t check_sum;

便利数据报的单个字节，就往check_sum上+

发送端会根据数据内容计算一个 校验和

数据到达接收端之后，也会重新计算一个校验和，接收端拿着自己计算好的检验和和发送端发过来的检验和对比，如果不相同，说明数据已经出错了

md5：字符串哈希算法

1.不管原字符串多长，得到的hash结果都是固定长度（64位/128位）。

2.远传如果相同，得到的hash值一定相同；远传如果不同（哪怕差别很小），得到的hash值也会差别很大

3.根据远传得到md5 很简单，但是根据md5推送会原串理论上基本不可能



































