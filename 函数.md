### 函数的参数 

#### 实际参数（实参）： 

> 真实传给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在 
>
> 进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。 

#### 形式参数（形参）：

>  形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单 
>
> 元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。 

**形参实例化之后其实相当于实参的 一份临时拷贝**

### 函数的参数 

#### 传值调用 

> 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。 

#### 传址调用 

> 传值调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。 
>
> 这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操作函数外部 
>
> 的变量。

C里面数是以补码方式来储存的 补码即原码除符号位外，全部取反再+1

1000000000000001取反后是1111111111111110，再+1即1111111111111111 



### 隐式类型转换

> C的整型算术运算总是至少以缺省整型类型的精度来进行的。 
>
> 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为**整型提升。**

`char a,b,c;  a=b+c;`

> b和c的值被提升为普通整型，然后再执行加法运算。 
>
> 加法运算完成之后，结果将被截断，然后再存储于a中。

#### 如何进行整型提升？

> 整形提升是按照变量的数据类型的符号位来提升的 

```c
//负数的整形提升 
char c1 = -1; 
变量c1的二进制位(补码)中只有8个比特位： 1111111 
因为 char 为有符号的 char 所以整形提升的时候，高位补充符号位，即为1 提升之后的结果是： 11111111111111111111111111111111 
    
//正数的整形提升 
char c2 = 1; 
变量c2的二进制位(补码)中只有8个比特位： 00000001 
因为 char 为有符号的 char 所以整形提升的时候，高位补充符号位，即为0 
提升之后的结果是： 
00000000000000000000000000000001 
    
//无符号整形提升，高位补0
```

#### 算术转换 

> 如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作 就无法进行。下面的层次体系称为**寻常算术转换。**
>
> ```c
> long double 
> double 
> float 
> unsigned long int 
> long int 
> unsigned int //无符号
> int
> //如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
> float f = 3.14; int num = f;//隐式转换，会有精度丢失
> ```

###  结构体

> 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量

#### 结构类型的成员

可以是标量、数组、指针，甚至是其他结构体。

#### 定义和初始化

```c
struct Point
{
    int x;
    int y; 
}p1; //声明类型的同时定义变量p1
struct Point p2; //定义结构体变量p2
//初始化：定义变量的同时赋初值。
struct Point p3 = {x, y};
struct Stu        //类型声明
{
    char name[15];//名字
    int age;      //年龄
};
struct Stu s = {"zhangsan", 20};//初始化
struct Node
{
    int data;
    struct Point p;
    struct Node* next; 
}n1 = {10, {4,5}, NULL}; //结构体嵌套初始化
struct Node n2 = {20, {5, 6}, NULL}；//结构体嵌套初始化
```

#### 结构体成员的访问 

> 结构体变量访问成员 结构变量的成员是通过点运算符(.)访问的。
>
> `s.age=20;`
>
> 结构体指针访问指向变量的成员 有时候我们得到的不是一个结构体变量，而是指向一个结构体的指针。 
>
> ```c
> struct Stu
> {
>     char name[20];
>     int age;
> };
> void print(struct Stu* ps) {
>     printf("name = %s   age = %d\n", (*ps).name, (*ps).age);
>     //使用结构体指针访问指向对象的成员
>     printf("name = %s   age = %d\n", ps->name, ps->age);
> }
> int main()
> {
>     struct Stu s = {"zhangsan", 20};
>     print1(s);//传结构体
>     print2(&s);//结构体地址传参
>     return 0; }
> //首先print2 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。       ∴结构体传参的时候，要传结构体的地址。
> ```

### Debug和Release 

> **Debug** 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。
>
> **Release** 称为发 布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。

#### 调试时候最常使用的几个快捷键

>  **F5** 
>
> 启动调试，经常用来直接调到下一个断点处。 
>
> **F9** 
>
> 创建断点和取消断点 断点的重要作用，可以在程序的任意位置设置断点。这样就可以使得程序在想要的位置 
>
> 随意停止执行，继而一步步执行下去。 
>
> **F10** 
>
> 逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。 
>
> **F11** 
>
> 逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是最长用 
>
> 的）。 
>
> **CTRL + F5** 
>
> 开始执行不调试，如果你想让程序直接运行起来而不调试就可以直接使用。