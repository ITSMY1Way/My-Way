## 冯诺依曼/普林斯顿体系结构： 





> cpu(中央处理器)上面也能存储少量的数据（最多几k字节）
>
> cpu上存数据的组件“寄存器”   ，访问速度特别快
>
> 这里的存储器指的是内存
>
> 不考虑缓存情况，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)
>
> 外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取。
> 所有设备都只能直接和内存打交道

## 存储器

> 内存：空间比较小，访问速度快，成本较高，断电之后数据丢失
>
> 外存：空间比较大，访问速度慢，成本较高，断电之后数据依然存在    
>
> 速度差3-4个数量级

> 猴子排序是时间复杂度无穷大的排序；睡眠排序是借助sleep实现的

## 操作系统

### 一、概念

任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。笼统的理解，操作系统包括：

> - 内核（进程管理，内存管理，文件管理，驱动管理）
> - 其他程序（例如函数库，shell程序等等

### 二、定位

> 操作系统是软件（OS）用来搞管理的软件： 要搭配驱动来 
>
> 1.管理硬件设备      2.管理软件资源

### 三、计算机管理硬件

> 描述：用struct结构体
>
> 组织： 用链表或其他高效的数据结构

## 进程

### 一、概念

> - 课本概念：程序的一个执行实例，正在执行的程序等
> - 内核观点：担当分配系统资源（CPU时间，内存）的实体
> - 进程  vs   可执行程序：无任何关联 
> - 编译成的可执行程序 test 是  文件  在外存上  当执行（./）时候，会将可执行文件加载到内中，

### 二、进程的管理（操作系统内核负责）

>  **描述进程** （PCB 进程控制块 —> 就是一个结构体）：一个进程对应一个task_struct 
>
>  **task_struct**  一个很大的结构体，是Linux操作系统下的PCB，包含很多内容  （是Linux中描述进程的结构体）    
>
>  **PCB **（指针通用的情况 ）进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合

### 查看进程

进程的信息可以通过 /proc 系统文件夹查看

1.进程标识符PID 进程的身份标识（区分标准） 

2.内存指针（进程代码和数据都在内存的哪个部分） 



### 三、通过系统调用创建进程-fork基本使用

```c
include <stdio.h>
include <sys/types.h>
include <unistd.h>
int main()
{
 int ret = fork();
 if(ret < 0){
 perror("fork");
 return 1;
 }
 else if(ret == 0){ //child
 printf("I am child : %d!, ret: %d\n", getpid(), ret);
 }else{ //father
 printf("I am father : %d!, ret: %d\n", getpid(), ret);
 }
 sleep(1);//加sleep与不加的结果分析：休眠过程不占CPU资源    
 return 0;
}
```

> - fork有两个返回值；父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝）
>
> - fork的使用： 
>
>   1.返回值：一次调用有两个返回值(有两个进程)   父进程返回子进程的pid 子进程返回0       一个父亲可以有多个儿子​通常要让父子进程执行不同的逻辑，就可以借助fork的返回值来进行区分；
>
>   如果失败，返回<0的结果        **a.内存不够  b.进程太多，达到上限了；**     RLIMIT_NPROC
>
>   2.执行过程：父子进程都是紧接这fork继续执行;
>
>   3.父子执行的先后顺序：取决于操作系统的调度器，不确定

### 四、进程状态

> - R 就绪状态，进程在就绪队列中，就会处于这个状态。(程序不一定在运行中)
> - S  睡眠状态/可中断睡眠，进程在等待事件完成（单身状态，暂时轮不到我，随时可能被唤醒）。
> - D 磁盘睡眠状态/磁盘休眠状态，装睡的人，密集的进程IO操作的时候   吐 coredump
> - T: 停止状态，STOP 暂停
> - t：trace跟踪   gdb调试会进入此状态
> - X：死亡状态，进程结束    这是在Linux源码中不存在，真实是看不到的，结构体已释放
>

#### 进程状态查看

> `ps`相当于任务管理器，可以查看系统中有哪些进程
>
> `ps -` 显示当前用户的进程
>
> `ps aux -`操作系统的所有进程
>
> `ps aux | less`      对查看结果可翻页其他操作
>
> `ps aux | grep`  【进程页】查看匹配的进程
>
> 敲下的命令，在命令执行过程中，也是一个进程

####  Z：僵尸进程  

> - 僵尸进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。
>   所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态
> - 危害：内存泄漏
> - 成因：子进程结束之后，父进程没有回收子进程的资源，为了解决子进程向父进程汇报工作的问题
> - 处理：无法kill强制关闭僵尸进程，可以kill僵尸进程的父进程（不太合适的方案）更科学的处理方案——进程等待
> -  为什么kill附近吃后僵尸进程就没了？kil了之后，子进程成为了孤儿进程，孤儿进程会被1号进程收养，从而释放资源     

#### 组织进程

> 可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里。双向链表进行组织，每个节点就是一个task_struct  。

### 五、孤儿进程

> 父进程先退出，子进程就称之为“孤儿进程”
>
> 孤儿进程不是一种进程的状态，指的是父进程结束后，但是子进程还在，子进程的父亲就变成了一号进程（init）。（孤儿进程被1号init进程领养)

## 环境变量

#### 概念

> - 环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，在系统中通常具有全局特性
> - 环境变量是一个键值对结构，  键：变量名 值：变量内容

#### 常见环境变量

> - PATH : 指定命令的搜索路径 
> - HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
> - SHELL : 当前Shell,它的值通常是/bin/bash

#### 查看方法

> - `env` 查看系统上所有的环境变量
> - `echo $(环境变量名)` 查看某个环境变量
>
> - `export` 修改环境变量 对于PATH 修改一般只是进行追加，不会把原来的内容去掉，可以通过重启终端来恢复PATH，修改文件~/bashrc能够让环境变量持久生效
> - `unset`: 清除环境变量
> - `set`: 显示本地定义的shell变量和环境变量

#### 通过代码如何获取环境变量

```c
#include <stdio.h>
int main(int argc, char *argv[])
{//通过第三方变量environ获取
 extern char **environ;
 int i = 0;
 for(; environ[i]; i++){
 printf("%s\n", environ[i]);
 }
 return 0;
}

```

```c
#include <stdio.h>
int main(int argc, char *argv[], char *env[])
{//命令行第三个参数
 int i = 0;
 for(; env[i]; i++){
 printf("%s\n", env[i]);
 }
 return 0;
}
```

**环境变量通常具有全局属性，可以被子进程继承下去**

## 进程地址空间

> 用C/C++语言所看到的地址，全部都是虚拟地址，物理地址，用户一概看不到，由OS统一管理，OS必须负责将虚拟地址 转化成 物理地址 。
>
> 同一个变量，地址相同，其实是虚拟地址相同，内容不同其实是被映射到了不同的物理地址！





> 栈的大小是？？？？8M？  
>
> Linux对于每个用户，系统限制其最大进程数。为提高性能，可以根据设备资源情况，设置各linux 用户的最大进程数，，， Linux是有文件句柄限制的。 ulimit 可以配置栈的大小
>
> 堆有多大    4G 32位系统   非常大
>
> 如果是大对象，必须在堆上分配
>
> 如果小地址，并且需要频繁创建和销毁，推荐在栈上分配 ，栈上分配更高效
>
> 堆上分配很复杂了  malloc底层实现



### 分页&虚拟地址空间



## 进程优先级

### 基本概念

cpu资源分配的先后顺序，就是指进程的优先权（priority）。
优先权高的进程有优先执行权利。配置进程优先权对多任务环境的linux很有用，可以改善系统性能。
还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，

### 查看系统进程

> - UID : 代表执行者的身份
> - PID : 代表这个进程的代号
> - PPID ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号
> - PRI ：表示这个进程是先被调度执行还是后被调度执行（优先队列是优先级高的先出）,PRI越小，优先级越高，越早被执行。
>
> ​       权限（你能做或者不能做）                 优先级(能做的情况下先后执行)    
>
> - ID : 代表执行者的身份
>
> - NI ：代表这个进程的nice值——>进程可被执行的优先级的修正数值， 优先级变低，   优先级的修正值，   PRI（old）+NI == 最终的PRI        通过top指令可以调整NI值，不过我们宏观上看不出
>
>   nice其取值范围是-20至19，一共40个级别       进入top后按“r”–>输入进程PID–>输入nice的值

> 进程的调度（让少量的CPU能够满足大量的进程）
>
> ​并行：多个进程在多个CPU下分别，同时进行运行，这称之为并行
> 并发: 多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为
> 并发（1个cpu分别执行2个进程，进程切换的方式）                        

#### context    上下文（寄存器） 

> CP可能有即几十寄存器  类似于游戏存档    PC指针（寄存器）
>
> 保存上下文，CP寄存器的内容保存到内存中；
>
> 恢复上下文，内存中的寄存器恢复到内存中