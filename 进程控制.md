## 进程创建

### fork函数

进程调用fork，当控制转移到内核中的fork代码后，内核做：

> - 分配新的内存块和内核数据结构给子进程
> - 将父进程部分数据结构内容拷贝至子进程
> - 添加子进程到系统进程列表当中
> - fork返回，开始调度器调度

> - 当一个进程调用fork之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。fork之前父进程独立执行，fork之后，父子两个执行流分别执行。
> - fork的运行规则：以父进程位模板，创建子进程：
> - 1.会把父进程的PCB拷贝一份，稍加修改成为子进程的PCB
> - 2.会把父进程的虚拟地址空间拷贝一份，作为子进程的地址空间
> - 3.fork返回会在父子进程中分别返回，父进程返回子进程的pid  子进程返回0，在fork往下继续执行
> - 4.父子进程的执行顺序有先后关系，全靠调度器来实现
> -  **fork失败返回 -1 内存不够/进程太多**

### fork常规用法

> - 一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求
> - 一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数

### fork调用失败的原因

> - 系统中有太多的进程
> - 实际用户的进程数超过了限制

### 写时拷贝

> - 父子进程公用一份代码，各自有一份数据（偷懒的方式 和懒加载是一样的）地址空间的内容过多的话，花销很大，如果写时，用多少写多少（早期的Linux中fork是深拷贝）
> - 由于大部分的内存空间可能被拷贝，创建进程开销仍然比较高，（和线程相比）
> - 在有些场景下，线程的创建也会被认为开销比较高（和协程）  Golang语言内置协程，简单好用（C语言原班人马打造的 天然可处理高并发的问题)

## 进程终止

### **进程终止三种方式**

> 1.代码执行完结果正确
>
> 2.代码执行完，结果不正确
>
> 3.代码没执行完，异常终止

### **进程常见退出方法（正常）**

`echo $?`  查看进程退出码 ，$?是 在bash中的一个特殊变量，表示上个命令对应的进程的退出码

> 1. main函数返回，返回值叫做进程的退出码，通过这个退出码表示运行结果是否正确退出码为0表示结果正确，非0表示不正确
> 2. exit
> 3. _exit

#### exit函数与_exit函数

```c
#include <unistd.h>
void _exit(int status);
void exit(int status);
参数：status 定义了进程的终止状态，父进程通过wait来获取该值
```

> 1. exit(库函数) 也可以终止进程，填的终止码    本质上也是调用_exit(最后会调用) ，在调用之前，还做了
>
>    （1.关闭流并刷新缓冲区；2.还多调用了结束函数） 
>
>     atexit当程序/进程/main结束时，再执行另一段函数，函数指针//假设C语言执行一个过程，这个过程会写一个文件（临时文件）
>
> 2. _exit（系统调用）比较底层的操作，更灵活，不能刷新缓冲区

## 进程等待

> (解决僵尸进程)：父进程对子进程进行等待，等待是为了读取子进程的运行结果。引用和指针底层不一样的。

### 进程等待方法

#### wait方法

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int*status);
返回值：子进程的PID（成功返回被等待进程pid，失败返回-1）
        阻塞式等待，移至等到子进程结束才返回
参数：输出型参数，表示退出码+正常/异常退出 获取子进程退出状态,不关心则可以设置成为NULL
```

wait的注意事项：

> 1.每调用一次，回收一次子进程。 wait的调用次数必须于子进程的数量一致
>
>    wait的调用次数比较少，导致僵尸进程；多，没多出的wait会调用出错
>
> 2.如果有多个子进程，任何一个子进程结束都会出发wait的返回options 
>
>  很多Linux系统调用中，都会采用类似的参数作为一些辅助选项，改变运行行为 

#### waitpid方法

```c
pid_ t waitpid(pid_t pid, int *status, int options);
返回值： 当正常返回的时候waitpid返回收集到的子进程的进程ID； 
        如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0； 
        如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数： 
     pid： Pid=-1,等待任一个子进程。与wait等效。
     Pid>0.等待其进程ID与pid相等的子进程。 
status:
    WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）     WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码） 
options: 
    WNOHANGI（非阻塞）: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。 
    非阻塞轮询式的wait：好处是：能够更灵活的控制代码，充分利用等待时间去做其他事情；坏处：代码写起来更复杂
```

> waitpid能够等待某个指定子进程的退出，行为和wait非常相似（返回值规则，status参数）
>
> waitpid（-1，NULL，0）就和wait（NULL）是等价的

> 如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退出信息。
> 如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则进程可能阻塞。
> 如果不存在该子进程，则立即出错返回。

##### 进程的阻塞等待方式：

> 在执行设备操作时若不能获得资源则挂起进程，知道满足可操作的条件后再进行操作，被挂起的进程进入休眠状态。进入休眠状态，必须确保有一个地方能够唤醒休眠的进程，为确保唤醒发生，唤醒的 地方最可能发生在中断，因为硬件资源状态变化往往伴随一个中断。

```C
int main()
{
 pid_t pid;
 pid = fork();
 if(pid < 0){
   printf("%s fork error\n",__FUNCTION__);
   return 1;
 } else if( pid == 0 ){ //child
   printf("child is run, pid is : %d\n",getpid());
   sleep(5);
   exit(257);
 } else{
   int status = 0;
   pid_t ret = waitpid(-1, &status, 0);//阻塞式等待，等待5S
   printf("this is test for wait\n");
   if( WIFEXITED(status) && ret == pid ){
 printf("wait child 5s success, child return code is 
:%d.\n",WEXITSTATUS(status));
 }else{
 printf("wait child failed, return.\n");
 return 1;
 }
 }
 return 0;
}
```

##### 进程的非阻塞等待方式：

> 在不能进行设备操作时并不挂起，它或者放弃，或者不停的查询，  直到可以操作为止。只有read、write和open文件操作受非阻塞标志的影响。
>

```c
#include <stdio.h> 
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
int main()
{
   pid_t pid;
    
   pid = fork();
   if(pid < 0){
       printf("%s fork error\n",__FUNCTION__);
       return 1;
   }else if( pid == 0 ){ //child
       printf("child is run, pid is : %d\n",getpid());
       sleep(5);
       exit(1);
   } else{
       int status = 0;
       pid_t ret = 0;
       do
       {
           ret = waitpid(-1, &status, WNOHANG);//非阻塞式等待
           if( ret == 0 ){
               printf("child is running\n");
           }
           sleep(1);
       }while(ret == 0);
    
       if( WIFEXITED(status) && ret == pid ){
           printf("wait child 5s success, child return code is :%d.\n",WEXITSTATUS(status));
       }else{
           printf("wait child failed, return.\n");
           return 1;
       }
   }
   return 0;
}
```

## 进程程序替换

> fork创建出的子进程，和父进程是公用同一套代码，而实际上我们更需要的是创建出的子进程更够执行一份单独的代码（调用一种exec函数）。
>
> 1.程序替换不会创建新进程，也不会销毁进程，所以调用前后该进程的id并未改变
>
> 2.替换的是代码和数据(从可执行文件而来)
>
> 3.原有的堆和栈中的数据就不要了，根据新的代码的执行过程重新构建堆和栈的内容。
>
> 类似于双击 exe 执行一个程序的过程 (操作系统中的加载器模块）

#### 替换函数

```c
include <unistd.h>
//exec 函数族，函数有差异，底层原理完全相同
int execl(const char *path, const char *arg, ...);//最后一个参数必须是NULL，如果不填程序就是未定义
                                                  //l=> list    变长参数列表
int execlp(const char *file, const char *arg, ...);// p = PATH  会自动从PATH的目录中查找可执行程序
int execle(const char *path, const char *arg, ...,char *const envp[]);
                                                   //e(env) : 表示自己维护环境变量
int execv(const char *path, char *const argv[]);//v =>  vector 参数用数组
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);

//程序替换经常要搭配fork使用。一旦替换之后，会把原来进程的代码和数据都干掉，无法执行原来的代码了，
```

| 函数名 | 参数格式 | 是否带路径 |  是否使用当前环境变量  |
| :----: | :------: | :--------: | :--------------------: |
| execl  |   列表   |    不是    |           是           |
| execlp |   列表   |     是     |           是           |
| execle |   列表   |    不是    | 不是，字节组装环境变量 |
| execv  |   数组   |    不是    |           是           |
| execvp |   数组   |     是     |           是           |
| execve |   数组   |    不是    | 不是，字节组装环境变量 |

#### 借助进程控制开发迷你版shell程序 

> 1.打印一个提示符，并且让用户输入一个命令        gets（）  一次读一行。
>
> 2.解析输入的命令，找到对应的可执行程序   哪些是命令行参数识别出来（字符串切分）切分结果应该是一个字符串数组     //借助 strtok来实现  切分    
>
> strtok 执行过程// 1.执行过程会破坏原始的字符串； 2.内部保存上次的切分结果。      ls     \0     -l   \0    /  \0
>
> strtok（input，" "）返回指向第一个 | 的指针
>
> strtok（NULL，" "）返回指向  - 的指针
>
> strtok（NULL，" "）返回指向  /  的指针
>
> strtok（NULL，" "）返回NULL
>
> strtok 必须循环调用，并且第一次的参数和后续的参数不一样
>
> 3.创建子进程，子进程程序替换，来 加载可执行程序													
>
> 4.父进程进行进程等待，等待子进程结束
>
> 5.子进程技术，父进程从wait中返回，循环执行1

#### 实现代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#define MAX_CMD 1024
char command[MAX_CMD];
int do_face()
{
   memset(command, 0x00, MAX_CMD);
   printf("minishell$ ");
   fflush(stdout);
   if (scanf("%\n%*c", command) == 0) {
       getchar();
       return -1; 
   }   
   return 0;
}
char **do_parse(char *buff)
{
   int argc = 0;
   static char *argv[32];
   char *ptr = buff;
   while(*ptr != '\0') {
       if (!isspace(*ptr)) {
           argv[argc++] = ptr;
           while((!isspace(ptr)) && (ptr) != '\0') {
               ptr++;
           }
           continue;
       }
       *ptr = '\0';
       ptr++;
   }
   argv[argc] = NULL;
   return argv;
}
int do_exec(char *buff)
{
   char **argv = {NULL};
   int pid = fork();
   if (pid == 0) {
       argv = do_parse(buff);
       if (argv[0] == NULL) {
           exit(-1);
       }
       execvp(argv[0], argv);
   }else {
       waitpid(pid, NULL, 0);
   }
   return 0;
}
int main(int argc, char *argv[])
{
   while(1) {
       if (do_face() < 0)
           continue;
       do_exec(command);
   }
   return 0;
}
```

**myhell的改进点**

> 1.自动获取当前的路径名，主机名，用户名
>
> 2.需要支持cd命令（cd修改的是子进程的路径，对父进程没影响）
>
> 需要让父进程直接支持cd （而不是创建子进程/程序替换）
>
> 内建命令？？
>
> 其他是通过创建子进程来实现的。
>
> 3.支持定义别名（映射关系，即需要再程序中维护一个键值对数据结构）std::map      比如：ls -l = ll
>
> 4.支持管道 （讲了管道后支持 吧啊哈哈哈）
>
> 5.支持重定向