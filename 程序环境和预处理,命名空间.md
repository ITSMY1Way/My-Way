## #define

```c
//#define 定义标识符
#define MAX 1000
#define reg register          //为 register这个关键字，创建一个简短的名字
#define do_forever for(;;)     //用更形象的符号来替换一种实现
#define CASE break;case        //在写case语句的时候自动把 break写上。
// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \
                          date:%s\ttime:%s\n" ,\
                          __FILE__,__LINE__ ,       \
                          __DATE__,__TIME__ )  
//在define定义标识符的时候，不要在最后加上 ; 
//#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。
```

参数列表的左括号必须与name紧邻。 如果两者之间有任何空白存在，参数列表就会被解释为stuffff的一部 分。 

所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符 

或邻近操作符之吉安不可预料的相互作用。

#####defifine 替换 在程序中扩展#defifine定义符号和宏时，需要涉及几个步骤。 

> 1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#defifine定义的符号。如果是，它们首先被替换。 
> 2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。 
> 3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#defifine定义的符号。如果是，就重复上述处理过程。 

> 1. 宏参数和#defifine 定义中可以出现其他#defifine定义的变量。但是对于宏，不能出现递归。 
> 2. 当预处理器搜索#defifine定义的符号的时候，字符串常量的内容并不被搜索。

**使用 # ，把一个宏参数变成对应的字符串**

```c
int i = 10;
#define PRINT(FORMAT, VALUE)\
printf("the value of " #VALUE "is "FORMAT "\n", VALUE);
...
PRINT("%d", i+3);//产生了什么效果？
the value of i+3 is 13
```

 **## 可以把位于它两边的边的符号合成一个符号。 它允许宏定义从分离的文本片段创建标识**

```c
#define ADD_TO_SUM(num, value) 
    sum##num += value; 
... 
ADD_TO_SUM(5, 10);//作用是：给sum5增加10. 
注： 这样的连接必须产生一个合法的标识符。否则其结果
```

### 宏和参数

> 1.用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程 
>
> 序的规模和速度方面更胜一筹。
>
> 2.更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎 可以适用于整形、长整型、浮点型等可以用于>来比较的类型。宏是类型无关的。 

和函数相比宏也有劣势的地方： 

> 1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。 
> 2. 宏是没法调试的。 
> 3. 宏由于类型无关，也就不够严谨。 
> 4. 宏可能会带来运算符优先级的问题，导致程容易出现错。 
>
> **宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到**
>
> ```c
> #define MALLOC(num, type)\
> (type *)malloc(num * sizeof(type))
> ...
> //使用
> MALLOC(10, int);//类型作为参数
> //预处理器替换之后：
> (int *)malloc(10 * sizeof(int));
> ```

### 宏和函数的对比

|       属性       | defifine定义宏                                               | 函数                                                         |
| :--------------: | :----------------------------------------------------------- | :----------------------------------------------------------- |
|     代码长度     | 每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长 | 函数代码只出现于一个地方；每次使 用这个函数时，都调用那个地方的同一份代码 |
|     执行速度     | 更快                                                         | 存在函数的调用和返回的额外开销，所以相对慢一些               |
|   操作符优先级   | 宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号 | 函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求职结果更容易预测 |
| 带有副作用的参数 | 参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果 | 函数参数子只在传参的时候求值一次，结果更容易控制             |
|     参数类型     | 宏的参数与类型无关，只要对参数的操作是合法的，它就 可以使用于任何参数类型 | 函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数， 即使他们执行的任务是不同的。 |
|       调试       | 宏是不方便调试的                                             | 函数是可以逐语句调试的                                       |
|       递归       | 宏是不能递归的                                               | 函数是可以递归的                                             |

### #undef

```
//这条指令用于移除一个宏定义。
#undef NAME 
//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。
```

### 条件编译

```c
1.
#if 常量表达式
//...
#endif
//常量表达式由预处理器求值。
如：
#define __DEBUG__ 1
#if __DEBUG__
//..
#endif
2.多个分支的条件编译
#if 常量表达式
//...
#elif 常量表达式
//...
#else
//...
#endif
3.判断是否被定义
#if defined(symbol)
#ifdef symbol
#if !defined(symbol)
#ifndef symbol
4.嵌套指令
#if defined(OS_UNIX)
#ifdef OPTION1
unix_version_option1();
#endif
#ifdef OPTION2
unix_version_option2();
#endif
#elif defined(OS_MSDOS)
#ifdef OPTION2
msdos_version_option2();
#endif
#endif
```

如果comm.h和comm.c是公共模块。 test1.h和test1.c使用了公共模块。 test2.h和test2.c使用了公共模块。 test.h和 test.c使用了test1模块和test2模块。 这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重 复。 

解决：**条件编译**

```
#ifndef __TEST_H__
#define __TEST_H__
//头文件的内容
#endif //___TEST___H
或者：#pragma once
```

## 命名空间

> 在C/C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染。namespace关键字的出现就是针对这种问题的。
>
> 一个项目组内多个工程师进行开发，有可能会出现全局变量或函数重名的现象，而如果每个人都定义了自己的命名空间，就可以解决这个问题，即使重名，只要分属不同的命名空间就不会引起问题。
>
> 使用`“命名空间     ::（作用域操作符）  标识符名称”`的方式就可以访问命名空间中的变量或函数

#### 命名空间的定义

> 定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空 
>
> 间的成员。
>
> using namespace  * ;（这里的 * 表示可以是任何命名空间）的作用是释放命名空间*中的变量或函数等，使之在被访问时可以不必加“命名空间::”，访问方法与一般的变量或函数无异，就像上面的cout一样。
>
> ```cpp
> //1. 普通的命名空间
> namespace N1  // N1为命名空间的名称
> {
> // 命名空间中的内容，既可以定义变量，也可以定义函数
> int a;
> int Add(int left, int right) {
>     return left + right; 
>     }
> }
> //2. 命名空间可以嵌套
> namespace N2
> {
> int a;
> int b;
> int Add(int left, int right) {
>     return left + right; }
> namespace N3
> {
>     int c;
>     int d;
>     int Sub(int left, int right)
>    {
>         return left - right;
>    }
> }}
> //3. 同一个工程中允许存在多个相同名称的命名空间
> //   编译器最后会合成同一个命名空间中。
> namespace N1
> {
> int Mul(int left, int right) {
>     return left * right; }}
> //一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中
> ```

#### 命名空间的3种使用方式

> - 加命名空间名称及作用域限定符 
>
> ```cpp
> int main()
> {
>    printf("%d\n", N::a);
>    return 0;    
> }
> ```
>
> - 使用using将命名空间中成员引入
>
> ```cpp
> using N::b;
> int main()
> {
>    printf("%d\n", N::a);
>    printf("%d\n", b);
>    return 0;    
> }
> ```
>
> - 使用using namespace 命名空间名称引入 
>
> ```cpp
> using namespce N;
> int main()
> {
>    printf("%d\n", N::a);
>    printf("%d\n", b);
>    Add(10, 20);
>    return 0;    
> }
> ```

