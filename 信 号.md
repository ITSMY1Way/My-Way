## 信号概念

> 信号是进程之间事件异步通知的一种方式，属于软中断
>
> 信号的作用，相当于神经系统，帮助操作系统来处理运行过程中遇到的各种意外情况

> 信号是一个计数器，负责进行进程间的同步和互斥，整个计数器描述了可用资源的个数
>
> 每次有进程想申请一个可用资源的时候，计数器-1    p；
>
> 每次有进程想释放一个可用资源的时候，计数器+1    V；
>
> 如果计数器已经是0了，这时候再有进程想要申请资源：
>
> 1.进程会挂起等待 ；2.会放弃申请资源

#### `kill -l`命令可以察看系统定义的信号列表

编号34以上的是实时信号





#### 信号的处理方式

> 1.忽略此信号
>
> 2.默认处理行为（大部分信号的默认行为，都是终止进程）
>
> 3.捕捉信号                                   
>
> 
>
> 提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉(Catch)一个信号



#### 信号的特点：

> 1.信号有很多种
>
> 2.不同的信号，会有不同的处理方式
>
> 3.在信号发生之前，每种信号如何处理，我们都是知道的

> 







####  解引用空指针引发的后果有哪些？

> 1.程序崩溃
>
> MMU
>
> 
>
> man 2 kill 系统调用区块的手册，，

#### 共享内存使用步骤：

> 1.创建/打开共享内存对象
>
> 2.附加到共享内存对象上（shmat—>attcah，用法和malloc十分相似）
>
> 3.使用共享内存



> 队列：先进先出
>
> 优先队列：每次列出一个优先级最高的元素
>
> 消息队列（带类型的队列） 每次按照指定类型来处队列
>
> 广义：消息队列也是一个队列，每个元素都带有一个类型出队列的时，是按照指定类型来先进先出的











> cat 不写参数，，默认从标准输入读取数据。。。
>
> pidof cat  //获取制动名字的pid

##### kill的简单实现

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
int main(int argc, char* argv[]){
//为了实现简单，只进行处理一个进程
    if(argc != 3){
        prinyf("参数有误! ./mykill [signo] [pid]\n");
        return 1;
    }
    into signo = atoi(argv[1]+1);
    pid_t pid = atoi(argv[])
    printf("%d\n", signo)；
        return 0;
}
    
```

//c语言字符串转整数

1.atoi

2.sprintf/sscanf

```c
#include <stdio.h>
#include <sstdlib.h>

int main(){
    char str[] = "100";
    int num = atoi(str);
    prinft("%d/n",num);//1
    
    
    
    
    char str[] = "100";//2
    int num = 0;
    sscanf(str,"%d",&num);
    printf("%d/n",num);
}
    
```

c++中的   

1.stringtream

```c++
#include <stdio.h>
#include <sstdlib.h>
#include <unistd.h>
#include <string>

int main（）{
    std::stringstream  ss;
    str::string str = "100";
    int num = 0;
    ss << str;
    ss >> num;
    std::cout << num << std::end1;
    return 0;
}
```

2.std::stoi

```
std:: string str = "100";
int num = std::stoi(str);
std::cout << num << std::end1;

g++   1.cc  -std = c++11
```

boost

```boost
std::string str = "1000";
int num = boost =boost::lexcal_cash<int>
```

siginal



```
void Myhandler(int singno){  //MYhandler 是回调函数  
    
}

//可替换原有的
```



## 产生信号

#### 信号的产生

> 1键盘按键产生  ctrl + c => 2      ctrl + z =>19          ctrl + \  => 3
>
> 2.硬件条件产生  a.MMU产生的信号 —> 11 MMU负责从虚拟地址翻译成物理地址，如果发现虚拟地址非法，MMU硬件设备就会告诉操作系统这个情况。有操作系统给指定进程发送一个11号信号，=>内存访问越界/解引用空指针    b.CPU产生的信号—> 8
>
> 3.软件条件产生   PIPE 读端关闭，尝试写，此时就会触发SUGPIPE信号，管道破裂，TCP中一定的条件下也会出发到SIGPIPE信号
>
> 4.系统调用产生



#### 信号的捕捉流程

> 信号处理函数是一个独立的执行流，和原有的用户代码之间没有相互调用关系（重要）
>
> 信号在处理函数执行过程中，原有的执行流在等待（重要）

## 阻塞信号

有的时候信号不会立刻被处理，而是要等到时机合适再进行处理

## 信号捕捉







操作系统给进程发信号，本质上就是再未决信号集中写一个信号的信息（几号信号）。

标识哪些信号布里克处理，通过一些函数来操作阻塞信号集



同一时刻一个进程收到了大量的2号信号，极有可能只处理一次





一个函数如果再多个执行流中被调用，就可能会出现问题

可重入函数：若一个函数可重入，意味着再多个执行流中调用是没问题的；

不可，有问题

如果一个函数使用了全局变量/静态变量，不可重入；

如果一个函数使用了malloc ，不可重入；

调用了不可重入的函数，也是不可重入的。





#### c语言关键字 volatile

```c
void MyHandler(int sig ){         //  初始的
    
voiatile void MyHandler(int sig ){//加上 voiatile//告诉变量必须每次都从内存中存取，不敢优化到寄存器中
    //功能： 保存内存可见性
    (void)sig;
    flag = 0;   
}
int main()
{
    signal(2,MyHandler);
    while(flag);//把内存中的数据读到CPU中
    return 0;
}

//Makefile  -O2之后，  编译器优化级别
 O0  O1 O2 O3
 //由于 while循环需要频繁读取flag到寄存器中，编译器就会判定这是一个比较高的开销；另一方面，编译器没检测到哪个代码需要修道flag（MyHandler函数是由内核调用的，编译器并不知道），编译器就出现了错误的判断，就直接把flag这个值优化到寄存器中
```

 volatile经常要使用再多线程程序中，编译器对于这种多执行流的情况是不太会判断的

c中原先的auto：表示变量可以自动访问内存



wait 阻塞等待    //代码简单，但是效率低

waitpid 阻塞/非阻塞  //充分利用等待时间做其他事情,效率高·

两全其美：SIGCHLD 17号信号  子进程结束后，父进程会发

```c
void MyHandler(int sig){
    (void)g;
    wait(NULL);
}
int main(){
    signal(17,MyHandler);
    pid_t ret = fork;
    it (ret > o){//father
        
        
    }
        
```

多个信号同时到达，亏能只被处理一次

//非阻塞式轮询可以解决

```c
void MyHandler(int sig){
    (void)sig;
    printf("cgild exit\n");
    while(1)
    {
        //如果ret > 0 已经会受到一个进程了，返回值是子进程的pid
        // = 0    还有子进程再，但是子进程没结束
       // < 0 没u有子进程了
    }
    wait(NULL);
}


signal（SIGCHLD , SIG_IGN） //忽略信号     直接避免子进程僵死进程
```



每次打开一个文件描述符表的时候，会从文件描述符表的开始位置一次往后找，找到第一个空闲的下标位置，就用整个下标来表示文件位置。

缓冲区的常见策略：

1.没缓冲      write系统调用就没

2.行缓存：遇到\n就刷新，或者缓冲区慢才刷新，或者手动刷新         打印到显示器

3.全缓冲：一直到缓冲区满才刷新，或者手动刷新                                              输出到文件





动态链接库：把一些.c/.cpp文件编译生成了一种特殊的二进制程序，自身不能直接执行，但是可以被其他的可执行程序调用

应用场景：客户端更新的时候不必更新整个程序，二十更新其中的一部分模块，其中的模块就是以动态库的方式组织的。





静态链接库：把一些.o文件打包到一起生成了一种特殊的二进制程序，自身不能直接执行，

但是可以和其他.c/.cpp文件编译生成一个新的可执行程序，这个新的可执行程序就可以单独发布了

应用场景：发布小程序的时候，可以使用静态库的方式编译生成一个单独的可执行程序并且不依赖其他的库，发布比较方便



命名规则：lib前缀     .a后缀（静态库）   .so后缀（动态库）

libadd.a:add.c

  gcc -c add.c -o add.o

  ar -rc libadd.a   add.o



libadd.so:add.c

   gcc add.c -shared -fPIC  -o   libadd.so

ldd 命令查看一个可执行程序依赖了哪些动态库

LD_LIBRARY_PATH  设定整个环境变量提醒系统去哪些目录中查找动态库

c++的第三方库一般都需要通过源码编译生成动态库或者静态库才能使用，但是由于编译环境的差异，编译过程中出现问题的概念极大，整个过程特别痛苦

其他主流语言都是使用类似于yum这样的包管理器来解决的

Python pip

JavaScript   npm

Go  go

为啥要进程通信？

进程之间具有独立性，每个进程都有字节的虚拟地址空间，进程A并不知道B的虚拟地址空间中的数据内容

进程通信需要  介质   ，两个进程都能访问到的公共资源

借助文件就可以完成进程间通信，最简单的进程间通信的方法



操作系统专门提供的进程间通信方式：匿名管道 命名管道 消息队列 共享内存 信号量

最重要的进程间通信方式：网络

管道就是在内核中的一块内存（构成了一个队列），使用一堆文件描述符来进行访问整个内存，读文件描述符是在从队列中取数据；学问家描述符就是往队列中插入数据。

































