> 运算打印符endl：
>
> 被称为操纵符的特殊值，输入的效果是结束当前行，并将与设备关联的寄存器中的内容刷到设备中。可保证到目前位置程序所残生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。 

> **宏的优缺点？** 
>
> 优点： 
>
> 1.增强代码的复用性。 
>
> 2.提高性能。 
>
> 缺点： 
>
> 1.不方便调试宏。（因为预编译阶段进行了替换） 
>
> 2.导致代码可读性差，可维护性差，容易误用。 
>
> 3.没有类型安全的检查 。 
>
> **C++有哪些技术替代宏？** 
>
> > 1. 常量定义 换用const 
> > 2. 函数定义 换用内联函数

### 1. 函数重载 

> 函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形 参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题.
>
> ```cpp
> int Add(int left, int right) {
> return left+right; }
> double Add(double left, double right) {
> return left+right; }
> long Add(long left, long right) {
> return left+right; }
> int main()
> {
> Add(10, 20);
> Add(10.0, 20.0);
> Add(10L, 20L);
> return 0; }
> ```
>
> 

###  2.extern “C” 

> 有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern "C"，意思是告诉编译器，将 该函数按照C语言规则来编译。
>
> ```cpp
> extern "C" int Add(int left, int right);
> int main()
> {
> Add(1,2);
> return 0; }
> ```

### 3.引用

> #### 3.1引用概念
>
> 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引 用的变量共用同一块内存空间。
>
> 类型& 引用变量名(对象名) = 引用实体；
>
> ```cpp
> void TestRef()
> {
> int a = 10;
> int& ra = a;//<====定义引用类型
> printf("%p\n", &a);
> printf("%p\n", &ra);
> }
> //注意：引用类型必须和引用实体是同种类型的
> ```
>
> #### 3.2引用特征
>
> > 1. 引用在定义时必须初始化 
> > 2. 一个变量可以有多个引用 
> > 3. 引用一旦引用一个实体，再不能引用其他实体
>
> #### 3.3常引用
>
> ```cpp
> void TestConstRef()
> {
> const int a = 10;
> //int& ra = a;   // 该语句编译时会出错，a为常量
> const int& ra = a;
> // int& b = 10; // 该语句编译时会出错，b为常量
> const int& b = 10;
> double d = 12.34;
> //int& rd = d; // 该语句编译时会出错，类型不同
> const int& rd = d; }
> ```
>
> #### 3.4使用场景
>
> 1.做参数
>
> ```cpp
> void Swap(int& left, int& right) {
>    int temp = left;
>    left = right;
>    right = temp;
> }
> ```
>
> 2.做返回值
>
> ```cpp
> int& TestRefReturn(int& a) {
>    a += 10;
>    return a; 
> }
> ```
>
> #### 3.5引用&指针
>
> 在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。 
>
> 在底层实现上实际是有空间的，因为 引用是按照指针方式来实现的。
>
> **不同点：**
>
> > 1. 引用在定义时必须初始化，指针没有要求 
> > 2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实 体 
> > 3. 没有NULL引用，但有NULL指针 
> > 4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4 个字节) 
> > 5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 
> > 6. 有多级指针，但是没有多级引用 
> > 7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理 
> > 8. 引用比指针使用起来相对安全

### 4.内联函数

> 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销， 
>
> 内联函数提升程序运行的效率。
>
> #### 4.1特征
>
> > 1. inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使 用作为内联函数。 
> > 2. inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等 等，编译器优化时会忽略掉内联。 
> >
> > 3. inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。

#### 5.auto关键字(C++11) 

> 在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量。 
>
> C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指 示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。
>
> 使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类 
>
> 型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变 
>
> 量实际的类型。
>
> #### 5.1使用规则
>
> 1. auto与指针和引用结合起来使用 
>
>    用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&
>
>    ```cpp
>    int main()
>    {
>        int x = 10;
>        auto a = &x;
>        auto* b = &x;
>        auto& c = x;
>        cout << typeid(a).name() << endl;
>        cout << typeid(b).name() << endl;
>        cout << typeid(c).name() << endl;
>        *a = 20;
>        *b = 30;
>         c = 40;
>        return 0; }
>    ```

> #### 5.2auto不能推到的场景
>
> 1. auto不能作为函数的参数 
>
> 2. auto不能直接用来声明数组 
>
> 3.  为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法
>
> 4. auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进 
>
>    行配合使用
>
> 5. 不能定义类的非静态成员变量
>
> 6. 实例化模板不能使用auto作为模板参数
>
> #### 5.3基于范围的for循环
>
> 对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此C++11中引 入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。
>
> ```cpp
> void TestFor()
> {
> int array[] = { 1, 2, 3, 4, 5 };
> for(auto& e : array)
>      e *= 2;
> for(auto e : array)
>      cout << e << " ";
> return 0; }
> ```
>
> #### 5.4nullptr 与 nullptr_t 
>
> NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在 
>
> 使用空值的指针时，都不可避免的会遇到一些麻烦。
>
> 在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下 
>
> 将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。
>
> C++11提供了nullptr， 即：nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类 型，nullptr_t被定义在头文件中：
>
> `typedef decltype(nullptr) nullptr_t;`  
>
> > 1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。 
> > 2. 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。 
> > 3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。



#### 3.1引用概念

引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引 用的变量共用同一块内存空间。

类型& 引用变量名(对象名) = 引用实体； 

```cpp
void TestRef()
{
int a = 10;
int& ra = a;//<====定义引用类型
printf("%p\n", &a);
printf("%p\n", &ra);
}
//注意：引用类型必须和引用实体是同种类型的
```

#### 3.2特征



#### 3.3常引

#### 3.4使用场景

> #### 3.1引用概念
>
> 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
>
> **类型& 引用变量名(对象名) = 引用实体；** 
>
> ```cpp
> void TestRef()
> {
> int a = 10;
> int& ra = a;//<====定义引用类型
> printf("%p\n", &a);
> printf("%p\n", &ra);
> }
> ```
>
> #### 3.2 引用特性 
>
> > 1. 引用在定义时必须初始化 
> > 2. 一个变量可以有多个引用 
> > 3. 引用一旦引用一个实体，再不能引用其他实体
>
> #### 3.3 常引用 
>
> ```cpp
> void TestConstRef()
> {
> const int a = 10;
> //int& ra = a;   // 该语句编译时会出错，a为常量
> const int& ra = a;
> // int& b = 10; // 该语句编译时会出错，b为常量
> const int& b = 10;
> double d = 12.34;
> //int& rd = d; // 该语句编译时会出错，类型不同
> const int& rd = d; }
> ```
>
> #### 3.4使用场景
>
> 1.做参数
>
> ```cpp
> void Swap(int& left, int& right) {
>    int temp = left;
>    left = right;
>    right = temp; 
> }
> ```
>
> 2.做返回值
>
> ```cpp
> int& TestRefReturn(int& a) {
>    a += 10;
>    return a; 
> }
> ```
>
> #### 3.5引用&指针
>
> 在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。
>
> 在底层实现上实际是有空间的，因为 引用是按照指针方式来实现的。
>
> 