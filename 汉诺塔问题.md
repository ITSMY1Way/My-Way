### 问题描述

> 汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？

### 分析问题

> 假设除了a最下面的盘子之外，其他的63个都移动到了b上，这时候把最下面的盘子由a移动到c即可。
>
> 当最大的盘子由a移动到c，b上是是剩下的63个盘子。a空了，现在的任务是把63个从b转移到c。
>
> 子问题同原问题，只是调整规模64->63。方法类似，先将上面的62个盘子由b移到a，再将最下面的盘子移到c
>
> ......
>
> 即递归，定义一组基本操作，这组操作将规模小一点（或大一点）的操作当做一个整体——无需关心它的细节，只当它已经完成了，然后执行剩下的操作。而在更小或更大的规模中也依此操作，直到规模达到预定值
>
> f(n,a,b,c)之
>
> >   1.f(n - 1, a, c, b)，即将a棒上面的n-1个盘移到b棒，借助c棒。
> >
> >   2.move(a, c)，     即将在a棒上的一个盘移到c棒。 
> >
> >   3.f(n - 1, b, a, c)，即将b棒上面的n-1个盘移到c棒，借助a棒。

### 代码

```c
#include<stdio.h>
#include<stdlib.h> 
void move(char get, char put) {	
	printf("%c——>%c\n", get, put);
} 
void hanoit(int n, char a, char b, char c) {	
	if(n == 1){		
		move(a, c);	
	} 
	else {		
		hanoit(n - 1, a, c, b);		
		move(a, c);		
		hanoit(n - 1, b, a, c);	
	} 
} 

int main() {	
	int m;		
	scanf_s("%d", &m);	
	hanoit(m, 'A', 'B', 'C'); 	
	system("pause");	
	return 0;
}
```

