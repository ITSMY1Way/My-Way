# 指针及相关知识总结

## 一、什么是指针？

> 指针是编程语言中的一个对象，利用地址，它的值直接指向存在 电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。
>
> 指针变量名与内存位置之间的关联由编译器实现，硬件可通过地址访问内存位置

指针就是**变量**，用来存放地址的变量。（存放在指针中的值都被当成**地址**处理）

变量指针=变量的地址                            

 指针是（地址）≠指针变量（是变量）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

> main 函数内的变量不是全局变量，而是局部变量，只不过它的生命周期和全局变量一样长而已。
>
> 全局变量一定是定义在函数外部的

声明一个指针变量并不会自动分配任何内存，在对指针执行间接访问前，指针必须进行**初始化**，或者使它**指向现有的内存**，或者给它**分配动态内存**

将数值存储到指定的内存地址 ——  往内存0x12ff7c 地址上存入一个整数0x100 

```c
int * p=（int *）0x12ff7c
*p=0x100；//即*（int *）0x12ff7c = 0x100；
```

* #### 指针的大小

指针的大小是固定的**4/8**个字节（32位平台/64位平台）

* #### 间接访问操作符  *

*void不可以定义变量。因为定义变量前提要开辟空间，而void是空类型。*

*void*可以，但void *定义的变量不可被解引用。*  

通过一个指针访问它所指向的地址的过程称为**间接访问**或**解引用指针**。

## 二、指针的运算

* #### 对指针进行加 1 操作

  得到的是下一个**元素**的地址，而不是原有地址值直接加 1。所以，一个类型为 T 的指针的移动，以 sizeof(T) 为移动单位。

  | **一级指针** | 加上指向其类型的大小 |
  | ------------ | -------------------- |
  | **多级指针** | **直接+4**           |

* #### 指针± 整数

  只能用于数组中**指向某个元素的指针**

  标准规定：

  > 允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一 个元素之前的那个内存位置的指针进行比较。

  若结果所指向的位置在数组第1个元素之前或在最后1个之后，其效果是**未定义**的。

  如果      **—**      操作后结果产生的指针所指向的位置在数组第一个元素之前，那么它是**非法**的。

  

  让指针指向数组最后1个元素后面的那个位置是**合法**的，但对这个指针执行间接访问可能会**失败**。

  对于       **+**       结果指针指向数组最后一个元素后面的哪个内存地址仍然**合法**（但不能对这个指针执行间接访问操作，不过再**往后不合法了**。

* #### 指针-指针

  只有当两个指针都**指向同一个数组中的元素**时，才允许从一个指针减去另一个指针。

  结果是两个指针在内存中的距离（以**数组元素的长度**为单位）。

  若p1指向 `array[i]`                   p2指向 `array[j]`

  则 p2-p1     就是              j-i      的值

  p1-p2 是**合法**的是           i-j      的值

  若两指针指向的不是同一个数组中的元素，我们不知道两个数组在**内存中的相对位置**，两个指针之间的距离就没有意义。   

* #### 指针的关系运算

  **<           <=                           >           >=**

  前提是指向同一数组中的元素

## 三、指针常量

指针常量的本质是一个**常量**，并且使用指针来修饰它，那么说明这个常量的值应该是一个指针

其格式为：  `int const * p`或者 `const int* p`

声明：

```c
int a;
int *const p = &a; 
```

*（指针）和 const（常量） 谁在前先读谁 ； *象征着地址，const象征着内容；谁在前面谁就不允许改变。

间接访问操作只能作用于指针类型表达式，若要把25存储于位置100必须要**强制类型转换**。

`*(int *)100 = 25;`

## 四、二级指针

`char **p;`
定义了一个二级指针变量 p。p 是一个指针变量，在 32 位系统下占 **4 个 byte**。 

与一级指针不同的是，一级指针保存的是**数据的地址**，二级指针保存的是**一级指针的地址**。

*ppa 通过对ppa中的地址进行解引用，这样找到的是 pa ， *ppa 其实访问的就是 pa .

**ppa 先通过 *ppa 找到 pa ,然后对 pa 进行解引用操作： *pa ，那找到的是 a .

```c
int a = 12;
int *b = &a;
int **c = &b;
```

​                                                                       **双重间接访问**

| 表达式 | 相当的表达式 |
| ------ | ------------ |
| a      | 12           |
| b      | &a           |
| *b     | a,12         |
| c      | &b           |
| *c     | b,&a         |
| **c    | *b,a,12      |

##  五、NULL指针

表示**不指向任何东西**，要使一个指针变量为NULL，可以给它赋一个0值；

为了测试一个指针变量是否为NULL，可以将它与0进行比较；

<!--对一个NULL指针进行解引用是非法的-->

所以,**在对指针进行解引用之前，确保它并非NULL指针**

它被宏定义为 0：    `#define NULL 0`

`*&a = 25；`**把值25赋给a**。&产生变量a的地址。它是一个指针常量，接着*访问其操作数所表示的地址。

## 六、函数指针

函数指针是**指向函数的指针变量**。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向地址。有了指向函数的指针变量后，可用该指针变量调用函数

函数指针有两个用途：**调用函数**和**做函数的参数**。

```c
int func (int x);       /*声明一个函数 */
int (* f) (int x);      /*声明一个函数指针 */
f=func;                 /*将func函数的首地址赋给指针f */
```

或者使用下面的方法将函数地址赋给函数指针：

```c
 f = &func;
```

## 七、数组指针和指针数组

**指针数组** （储存指针的数组） 是**数组**，数组的元素都是指针，数组占多少字节由数组本身决定。

**数组指针** （指向数组的指针） 是**指针**  它指向一个数组，在32位系统下占4字节。

 `int (*  p）[10]`p先和 * 结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针,指向一个数组，叫**数组指针** 。储存储在哪里，我们并不知道。

<u>[]的优先级要高于 * 号的，所以必须加上（）来保证p先和 * 结合。</u>

`int *p[10];`

p 先与“[]”结合，构成一个数组的定义，数组名为 p1，int* 修饰的是数组的内容，即数组的每个元素。这是一个数组，其包含 10 个 指向 int 类型数据的指针，即**指针数组**。

## 八、a与 &a 

##### **&a[0] 和&a[]** (**a与 &a**)

a[0]是一个元素 a[]是整个数组  虽然他们的值一样，但意义不一样 

前者是**数组首元素的首地址**，后者是**数组的首地址**。

同理，a与 &a的值是一样的，但意义不同，前者是数组首元素的首地址，后者是数组的首地址。

## 九、数组名a作左右值区别

> 简单而言，出现在赋值符“=”右边的就是右值，出现在赋值符“=”左边的就是左值。 比如,x=y。

* a 作为右值时其意义与&a[0]是一样，代表的是数组首元素的首地址；

* **a 不能作为左值！**编译器会认为数组名作为左值代表的意思是a的首元素的首地址但是这个地址开始的一块内存是一个总体我们只能访问数组的某个元素而无法把数组当一个总体进行访问。

  所以我们可以把 a[i]当左值，而无法把 a 当左值。

## 十、函数指针数组

`char* (*pf[3])(char *p)` 定义的是一个**函数指针数组**pf，数组内储存了3给指向函数的指针。这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。

```c
include <stdio.h>
include <string.h>
char* fun1(char* p)
{
printf("%s\n",p);
return p;
}
char* fun2(char* p)
{
printf("%s\n",p);
return p;
}
char* fun3(char* p)
{
printf("%s\n",p);
return p;
}
int main()
{
char* (*pf[3])(char* p);
pf[0]= fun1; // 可以直接用函数名
pf[1]= &fun2; // 可以用函数名加上取地址符
pf[2]= &fun3;
pf[0]("fun1");
pf[0]("fun2");
pf[0]("fun3");
return 0;
}
```

## 十一、指向函数指针数组的指针

`char* (* ( * pf)[3])(char* p);`

这个指针指向一个包含了 3 个元素的数组；这个数字里面存的是指向函数的指针；这些指针指向一些返回值类型为指向字符的指针、参数为一个 指向字符的指针的函数

指向函数指针数组的指针是一个 **指针** 指针指向一个 **数组** ，数组的元素都是 **函数指针** ;

```c
include <stdio.h>
include <string.h>
char* fun1(char* p)
{
printf("%s\n",p);
return p;
}
char* fun2(char* p)
{
printf("%s\n",p);
return p;
}
char* fun3(char* p)
{
printf("%s\n",p);
return p;
}
int main()
{
char* (*a[3])(char* p);
char* (*(*pf)[3])(char* p);
pf = &a;
a[0]= fun1;
a[1]= &fun2;
a[2]= &fun3;
pf[0][0]("fun1");
pf[0][1]("fun2");
pf[0][2]("fun3");
return 0;
}
```

## 十二、指针和数组的对比

| 指针                                                         | 数组                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 保存数据的地址，任何存入指针变量 p 的数 据都会被当作地址来处理。p 本身的地址由 编译器另外存储，存储在哪里，我们并不知道 | 保存数据，数组名 a 代表的是数组首元素的 首地址而不是数组的首地址。&a 才是整个数 组的首地址。a 本身的地址由编译器另外存储，存储在哪里，我们并不知道。 |
| 间接访问数据，首先取得指针变量 p 的内容， 把它作为地址，然后从这个地址提取数据或 向这个地址写入数据。指针可以以指针的形 式访问* (p+i)；也可以以下标的形式访问 p[i]。 但其本质都是先取 p 的内容然后加上 i*sizeof(类型)个 byte 作为数据的真正地址 | 直接访问数据，数组名 a 是整个数组的名字， 数组内每个元素并没有名字。只能通过“具 名+匿名”的方式来访问其某个元素，不能把 数组当一个整体来进行读写操作。数组可以 以指针的形式访问* (a+i)；也可以以下标的形 式访问 a[i]。但其本质都是 a 所代表的数组首 元素的首地址加上 i*sizeof(类型)个byte作为 数据的真正地址。 |
| 通常用于动态数据结构                                         | 通常用于存储固定数目且数据类型相同的元素                     |
| 相关的函数为 malloc 和 free                                  | 隐式分配和删除                                               |
| 通常指向匿名数据（当然也可指向具名数据）                     | 自身即为数组名                                               |

## 十三、数组参数与指针参数

- #### 一维数组参数与一维指针参数

  > C 语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针;
  >
  > 当数组超过一维时，将第一维改写为指向数组首元素首地址的指针之后，后面的维度再也不可改写。
  >
  > 比如：`a[3][4][5]`作为参数时可以被改写为`(*p)[4][5]` 。
  >
  > C 语言中，所有非数组形式的数据实参均以传值形式（对实参做一份拷贝并传递给被调用的函数，函数不能修改作为实参的实际变量的值，而只能修改 传递给它的那份拷贝）调用
  >
  > 函数本身是没有类型的，只有函数的返回值才有

  数组传参时 降为 **指向其内部元素类型的指针**

  * **一维数组参数**

    <u>无法向函数传递一个数组</u>

    ```c
    void fun(char a[]) {
    charc = a[3];
    }
    int main()
    {
    char b[100]= “abcdefg”;
    fun(b);
    return 0;
    }
    ```

  * **一级指针参数**

    <u>无法把指针变量本身传递给一个函数</u>

    ```c
    char* GetMemory（char* p,int num）
    {
    p = (char*)malloc(num*sizeof(char));
    return p；
    }
    int main()
    {
    char*str= NULL;
    str= GetMemory（str，10）;
    strcpy(str,”hello”);
    free（str）；
    return 0;
    }
    ```

    ```c
    void GetMemory（char** p,int num）
    {
    *p = (char*)malloc(num*sizeof(char));
    return p；
    }
    int main()
    {
    char*str= NULL;
    GetMemory（&str，10）;
    strcpy(str,”hello”);
    free（str）；
    return 0;
    }
    ```

- #### 二维数组参数与二维指针参数

  `void fun（char (*p)[4];`

  `void fun（char a [][4] ;` 

​      二维数组传参，函数形参的设计只能省略第一个[]的数字。

* ####  二维数组的地址

  `int a[5][5]; `

   `int (*p)[4]; `

  a 在这里代表的是 a[0]的首地址。a+1 表示的是一维数组 a 的第二个元素。

  a[4]表示的是一维数组 a 的第 5 个元素，而这个元素里又存了一个一维数组。

  所以`&a[4][2]`表示的 是`&a[0][0]`+4* 5 * sizeof(int)+2*sizeof(int)

  p[4]相对于 p[0]来说是向后移动了 4 个“包含 4 个 int 类型元素的数组”
   即&p[4]表示的是&p[0]+4 * 4 * sizeof(int)。由于 p 被初始化为&a[0]，

  那么`&p[4][2]`表示的是 `&a[0][0]`+4 * 4 * sizeof(int)+2* sizeof(int)。

  `a [ i ][ j ]`的**首地址**是a+i*sizeof(类型) * j(总)+j*sizeof(类型) 

  即     ***( *(a+i)+j)**

* #### 二维数组参数和二维指针参数的等效关系

| 数组参数                 | 等效的指针参数            |
| ------------------------ | ------------------------- |
| 数组的数组：char a[3][4] | 数组的指针：char (*p)[10] |
| 指针数组： char *a[5]    | 指针的指针：char **p      |

##                                             练习

**一维数组** 

```c
int a[] = {1,2,3,4};
printf("%d\n",sizeof(* a));//*a是第一个元素 4 
printf("%d\n",sizeof(&a));//数组的地址  4
printf("%d\n",sizeof(*&a));//对数组指针解引用就是数组a16
printf("%d\n",sizeof(&a+1));//指向下一个数组的地址 4 
```

**字符数组** 

```c
char arr[] = {'a','b','c','d','e','f'}; 
printf("%d\n", sizeof(*arr));//第一个元素1
printf("%d\n", strlen(arr));//不确定，没有\0,至少6，若假设10，
printf("%d\n", strlen(arr+0));//10
printf("%d\n", strlen(*arr)); //报错 类型不匹配
printf("%d\n", strlen(arr[1]));//报错
printf("%d\n", strlen(&arr));// 10  
printf("%d\n", strlen(&arr+1));//4
printf("%d\n", strlen(&arr[0]+1));//第二个元素 开始9
```

```c
char *p = "abcdef"; 
printf("%d\n", strlen(*p)); //不匹配
printf("%d\n", strlen(p[0])); //不匹配
printf("%d\n", strlen(&p)); //不确定   3
printf("%d\n", strlen(&p+1)); //不确定 7
```

**二维数组** 

```c
int a[3][4] = {0}; 
printf("%d\n",sizeof(a[0]+1));//a[0]即数组名 +1就是第二个元素的地址a[0][1] 4 
printf("%d\n",sizeof(*(a[0]+1))); //4 
printf("%d\n",sizeof(a+1)); //4 第二个元素的地址a[1]
printf("%d\n",sizeof(*(a+1))); //16 第二个数组
printf("%d\n",sizeof(&a[0]+1)); //4 相当于a+1  a[1]的地址
printf("%d\n",sizeof(*(&a[0]+1))); //16   a[1]  第二个数组
printf("%d\n",sizeof(*a)); // 第一个数组 a[0] 16
printf("%d\n",sizeof(a[3]));// 错的 可以访问 
```

