## Linux下实现彩色的进度条程序

### 1.缓冲区

`缓冲区分为无缓冲、行缓冲、全缓冲。`

**无缓冲**

> 表示的是没有缓冲，可以将信息立马显现出来，典型代表是标准错误流stderr。

**行缓存**

> 0.表示的是输入输出遇到换行才执行真正的I/O操作。典型的代表是键盘的操作
>
> 1.缓冲区如果满了，就会真正写道显示器上   
>
> 2.如果遇到/n也会写道显示器上                    如果把数据写到文件中，/n就不能刷新缓冲区了
>
> 3.程序结束的时候也“可能”会刷新
>
> 4.fflush  手动刷新

**全缓冲**

> 表示的是输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。

### 2.进度条代码

>  printf是一个行缓冲函数，先写到缓冲区，满足条件后，才将缓冲区刷到对应文件中，刷缓冲区的条件如下：（任满足其一即可）
>
> (1)缓冲区填满；    
>
> (2)写入的字符中有‘\n’ ，'\r'；     
>
> (3)调用fflush手动刷新缓冲区；     
>
> (4)调用scanf要从缓冲区中读取数据时，也会将缓冲区内的数据刷新；

#### **/n  与  /r**

> /n表示换行，另起新行，光标来到下一行行首。可以起到刷新缓冲区的作用（只针对显示器）
>
> /r 表示回车，每次打印完光标回到最开始位置

```c
  1 #include <unistd.h>//usleep的头文件 只有再Linux下有这个头文件
  2 #include <string.h>
  3 #include <stdio.h>
  4 int main()
  5 {
  6   int i = 0;
  7   char bar[102];
  8   memset(bar, 0 ,sizeof(bar));
  9   const char *lable="|/-\\";
 10   while(i <= 100){
 11     printf("[%-100s][%d%%][%c]\r", bar , i , lable[i%4]);//  格式化输出，‘-’表示         左对齐，100表示固定列宽，[%d%%]是实现打印百分比，也可以[%d\%]，通过\%对%转义
 12     fflush(stdout);
 13     bar[i++] = '#';
 14     usleep(500 * 100);//调用该函数的线程挂起一段时间 刷新慢一点。Linux上是sleep                                 单位是s；uslessp的单位是微秒   写成500 *100可读性更好     
 15     }
 16   printf("\n");
 17   return 0;
 18 
 19 }
```

### 3.彩色版本

终端的字符颜色由转义序列控制，是文本模式下的系统显示功能，与具体语言无关。转义序列以控制字符'ESC'开头。多数转义序列超过两个字符，故通常以'ESC'和左括号'[‘开头。该起始序列称为控制序列引导符，通常由'\033[‘或'\e[‘代替。

```c
1 #include <unistd.h>
2 #include <string.h>
3 #include <stdio.h>
4 
5 #define NONE "\e[0m"//恢复默认颜色
6 #define RED  "\e[0;31m"//在实现中为了增加可读性将颜色定义为宏，再进行使用。
7 #define BLUE "\e[0;34m"
8 
9 int main()
10 {
11   int i = 0;
12   char bar[102];
13   memset(bar, 0 ,sizeof(bar));
14   const char *lable="|/-\\";
15   while(i <= 100){
16     if(i % 2){
17       printf(RED"[%-100s][%d%%][%c]\r"NONE, bar , i , lable[i%4]);
18     }
19 else
20       printf(BLUE"[%-100s][%d%%][%c]\r"NONE, bar , i , lable[i%4]);          
21       fflush(stdout);
22     bar[i++] = '#';
23     usleep(100000);
24     }
25   printf("\n");
26   return 0;
27 }

```



