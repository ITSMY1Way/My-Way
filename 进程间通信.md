每次打开一个文件描述符表的时候，会从文件描述符表的开始位置一次往后找，找到第一个空闲的下标位置，就用整个下标来表示文件位置。

缓冲区的常见策略：

1.没缓冲      write系统调用就没

2.行缓存：遇到\n就刷新，或者缓冲区慢才刷新，或者手动刷新         打印到显示器

3.全缓冲：一直到缓冲区满才刷新，或者手动刷新                                              输出到文件





动态链接库：把一些.c/.cpp文件编译生成了一种特殊的二进制程序，自身不能直接执行，但是可以被其他的可执行程序调用

应用场景：客户端更新的时候不必更新整个程序，二十更新其中的一部分模块，其中的模块就是以动态库的方式组织的。





静态链接库：把一些.o文件打包到一起生成了一种特殊的二进制程序，自身不能直接执行，

但是可以和其他.c/.cpp文件编译生成一个新的可执行程序，这个新的可执行程序就可以单独发布了

应用场景：发布小程序的时候，可以使用静态库的方式编译生成一个单独的可执行程序并且不依赖其他的库，发布比较方便



命名规则：lib前缀     .a后缀（静态库）   .so后缀（动态库）

libadd.a:add.c

  gcc -c add.c -o add.o

  ar -rc libadd.a   add.o



libadd.so:add.c

   gcc add.c -shared -fPIC  -o   libadd.so

ldd 命令查看一个可执行程序依赖了哪些动态库

LD_LIBRARY_PATH  设定整个环境变量提醒系统去哪些目录中查找动态库

c++的第三方库一般都需要通过源码编译生成动态库或者静态库才能使用，但是由于编译环境的差异，编译过程中出现问题的概念极大，整个过程特别痛苦

其他主流语言都是使用类似于yum这样的包管理器来解决的

Python pip

JavaScript   npm

Go  go

为啥要进程通信？

进程之间具有独立性，每个进程都有字节的虚拟地址空间，进程A并不知道B的虚拟地址空间中的数据内容

进程通信需要  介质   ，两个进程都能访问到的公共资源

借助文件就可以完成进程间通信，最简单的进程间通信的方法



操作系统专门提供的进程间通信方式：匿名管道 命名管道 消息队列 共享内存 信号量

最重要的进程间通信方式：网络

管道就是在内核中的一块内存（构成了一个队列），使用一堆文件描述符来进行访问整个内存，读文件描述符是在从队列中取数据；学问家描述符就是往队列中插入数据。

