### 结构体的声明

```c
struct Stu
{
     char name[20];//名字
     int age;//年龄
     char sex[5];//性别
     char id[20];//学号
}；//分号不能丢
    
//特殊的声明
//匿名结构体类型   在声明的时候省略掉了结构体标签（tag）
struct
{
     int a;
     char b;
     float c;   
}x;
struct
{
     int a;
     char b;
     float c;
}a[20], *p;
//自引用方式
struct Node
{
    int data;
    struct Node* next;
};
typedef struct Node
{
    int data;
    struct Node* next; 
}Node;
//结构体变量和初始化
struct Point
{
    int x;
    int y; 
}p1; //声明类型的同时定义变量p1
struct Point p2; //定义结构体变量p2
//初始化：定义变量的同时赋初值。
struct Point p3 = {x, y};
struct Stu        //类型声明
{
    char name[15];//名字
    int age;      //年龄
};
struct Stu s = {"zhangsan", 20};//初始化
struct Node
{
    int data;
    struct Point p;
    struct Node* next; 
}n1 = {10, {4,5}, NULL}; //结构体嵌套初始化
struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化

//传参
struct S {
    int data[1000];
    int num;
};
struct S s = {{1,2,3,4}, 1000};
void print1(struct S s) {
    printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S* ps) {
    printf("%d\n", ps->num);
}
int main()
{
    print1(s);  //传结构体
    print2(&s); //传地址
    return 0; 
}//选print2 参数是需要压栈的。 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。
```

```c
//写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//定义的这个宏将结构体里边的变量的地址取出后再强转成char型，然后进行相减。
//注意：&s == &s.num  （进行验证：请看代码2）
#define OFFSET(a, b) ((char*)(&b) - (char*)(&a))
#include <stdio.h>

typedef struct S{
	double num ;
	char ch ;
}S;

int main()
{
	S s ;
	printf("此结构体第二个变量相对于首地址的偏移为: %d\n", OFFSET(s, s.ch)) ;
	return 0 ;
}


```

### 结构体内存地对齐

> 1.第一个成员在与结构体偏移量为0的地址处。 
>
> 2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 
>
> 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 
>
> VS中默认的对齐数为8，
>
> Linux gcc没有默认对齐数：参考：https://blog.csdn.net/weixin_42678507/article/details/90109173
>
> 3.结构体总大小为：最大对齐数的整数倍。 
>
> 4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是      所有最大对齐数（含嵌套结构体的对齐数）的整数倍。 

> 在windows(32)/VC6.0下各种类型的变量的自身对齐参数就是该类型变量所占字节数的大小，
>
> 而在linux(32)/GCC下double类型的变量自身对齐参数是4，是因为linux(32)/GCC下如果该类型变量的长度没有超过CPU的字长，则以该类型变量的长度作为自身对齐参数，如果该类型变量的长度超过CPU字长，则自身对齐参数为CPU字长，而32位系统其CPU字长是4，所以linux(32)/GCC下double类型的变量自身对齐参数是4，如果是在Linux(64)下，则double类型的自身对齐参数是8。
>
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805133646129.png)
>
> 　　除了变量的自身对齐参数外，还有一个对齐参数，就是每个编译器默认的对齐参数#pragma pack(n)，这个值可以通过代码去设定，如果没有设定，则取系统的默认值。在windows(32)/VC6.0下，n的取值可以为1、2、4、8，默认情况下为8。注意像DEV-CPP、MinGW等在windows下n的取值和VC的相同。  

```c
//vs2013     #pragma pack(8)
struct S1
    {
        char c1;//1
        int i;//1xxx  1111
        short s2;//1xxx 1111  11xx
    };//结构体大小是10字节
    printf("%d\n", sizeof(struct S1));//整体对齐数是12
    struct S2
    {
        char c1;
        short s2;
        int i;
    };
    printf("%d\n", sizeof(struct S2));//8
struct s3
{
    int a;
    short b;
    static int c;//结构体中包含静态数据成员，而静态数据成员的存放位置与结构体实例的存储地址无关(只有在C++中结构体中才能含有静态数据成员)
                 //变量c是单独存放在静态数据区的，因此用siezof计算其大小时没有将c所占的空间计算进来
};//8
struct s4
{
    bool a;
    S1 s1;
    double b;
    int c;//1+3+8+4+8+4=28字节。
};//对于整个结构体来说，各个变量的最终对齐参数为1，4，8，4，最大值为8，#pragma pack(n)默认值为8，所以最终结构体的大小必须是8的倍数，因此需要在最后面填充4字节达到32字节
   //|--------bool--------|    4字节
 　//|---------s1---------|    8字节
 　//|--------------------|     4字节
 　//|--------double------|    8字节
 　//|----int----|---------|     8字节 
```

####  为什么要进行内存对齐?

> 1. 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址 处取某些特定类型的数据，否则抛出硬件异常。 
> 2. 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理 器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
>
>  结构体的内存对齐是拿空间来换取时间的做法。 
>
> 在设计结构体的时候，我们既要满足对齐，又要节省空间。 应该：让占用空间小的成员尽量集中在一起

#### **如何让结构体按照指定的对齐参数进行对齐?** 

```c
//使用预处理命令 #pragma
#include <stdio.h>
#pragma pack(8)//设置默认对齐数为8
struct S1
{
    char c1;
    int i;
    char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
```

#### **如何知道结构体中某个成员相对于结构体起始位置的偏移量?** 

```cpp
#include<iostream>
using namespace std;
#define offsetof(s,m) (size_t) &(((s*)0)->m)
struct N
{	int i;	
    char j;	
    double k; 
};
int main()
{	
    cout<<offsetof(N,j)<<endl;	
    return 0;
}//（s*）0:是骗编译器说有一个指向类（或者结构体）s的指针，它的值是0. 
//&（（（s*）0）->m）这个是取结构体中s的成员m,由于这个类的基址是0,这时m的地址就是在结构体中的偏移地址
```



类型所能标识的值的范围决定了转换的过程：

> - 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
> - 赋给带符号类型一个超出它表示的范围的值时，结果是未定义的，此时，程序可能继续关注，可能膨崩溃，也可能产生数据垃圾 
>

### 位段

> 声明和结构是相似的，不同：
>
> 1.位段的成员可以是 int ，unsigned int ，signed int 或者是 char （属于整形家族）类型  。
>
> 2.位段的成员名后边有一个冒号和一个数字。 
>
> ```c
> struct A {
>     int _a:2;
>     int _b:5;
>     int _c:10;
>     int _d:30;
> };
> printf("%d\n", sizeof(struct A));//8
> ```
>
> #### 内存分配
>
> > 1. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
> > 2. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
>
> #### 跨平台性：
>
> > 1.int 位段被当成有符号数还是无符号数是不确定的。 
> >
> > 2.位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问 
> >
> > 题。 
> >
> > 3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。 
> >
> > 4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的 
> >
> > 位还是利用

### 枚举

> 把可能的取值一一列举 
>
> ```c
> enum Day//星期
> {
>     Mon,
>     Tues,
>     Wed,
>     Thur,
>     Fri,
>     Sat,
>     Sun
> };
> enum Sex//性别
> {
>     MALE,
>     FEMALE,
>     SECRET
> }；
> enum Color//颜色
> {
>     RED = 1,
>     GREEN = 5,
>     BLUE = 4
> };
> enum Color clr = GREEN;//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异
> //以上定义的 enum Day ， enum Sex ， enum Color 都是枚举类型。 
> //{}中的内容是枚举类型的可能取值，也叫 枚举常量 。
> //这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。
> ```
>
> ### 优点
>
> > 1. 增加代码的可读性和可维护性
> > 2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
> > 3. 防止了命名污染（封装）
> > 4. 便于调试
> > 5. 使用方便，一次可以定义多个常量

### 联合（共用体） 

```c
//联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体），
//这样一个联合变量的大小，至少是最大成员的大小(因为联合至少得有能力保存最大的成员)
//声明。
union Un
{
	char c;
	int i;
};
//定义
union Un un;
printf("%d\n", sizeof(un));//4
int main()
{
	un.i = 0x11223344;
	un.c = 0x55;
	printf("%x\n", un.i);//11223355
	getchar();
	return 0;
}
```

#### 联合体大小计算

```c
//联合的大小至少是最大成员的大小
//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
union Un1
{
    char c[5];
    int i;
};
union Un2
{
    short c[7];
    int i;
};
//下面输出的结果是什么？
printf("%d\n", sizeof(union Un1));//8
printf("%d\n", sizeof(union Un2));//16
```

### 取余取模运算

> 对于整型数a，b来说，取模运算或者求余运算的方法都是：
>
> 1.求 整数商： c = a/b;
>
> 2.计算模或者余数： r = a - c*b.
>
> 求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。
>
> 例如计算：-7 Mod 4
>
> 那么：a = -7；b = 4；
>
> 第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；
>
> 第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。
>
> 归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。
>
> 当符号不一致时，结果不一样。商为负数。
>
> 另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。
>
> 补充：
>
> 7 mod 4 = 3（商 = 1 或 2，1<2，取商=1）
>
> -7 mod 4 = 1（商 = -1 或 -2，-2<-1，取商=-2）
>
> 7 mod -4 = -1（商 = -1或-2，-2<-1，取商=-2）
>
> -7 mod -4 = -3（商 = 1或2，1<2，取商=1）
>
> 这里模是4，取模其实全称应该是取模数的余数，或取模余。
> 
> 取模运算时,对于负数,应该加上被除数的整数倍,使结果大于或等于0之后,再进行运算.
对于上例:
-1+256=255,然后用255%256,结果就是255.
当然也可以-1+512=511,511%256的结果也是255.




> 以0开始投的整数代表八进制数
>
> 以0x / 0X开头的代表十六进制数
>
> 十进制就是正常的

"A" 字符串代表了一个字符的数组，该数组还包含空字符'\0'

‘A’字面值表示的就是单独的字符A

如果\后面跟着的八进制数字超过3个，只要前三个数字与\构成转义序列。

理解r的类型是声明，最简单的办法是从右向左阅读r的定义。

离变量名最近的符号对变量的类型有最直接的影响。

临时量对象——当编译器需要一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
