> 1. deque(发音类似“deck”)，是双端队列不规则的首字母缩写，双端队列是动态大小的序列式容器，其可 以像两端进行伸缩。
> 2. 特定的库可以以不同的方式实现deque，但通常都是一种动态数组。不论在何种情况下，它都允许通过 随机访问迭代器直接访问单个元素，可以根据需要动态的伸缩。 
> 3. 因此，deque提供了一些与vector相似的功能，但deque在头部和尾部进行数据插入和删除操作更加高 效。与vector不同的是，deque不能保证所有的元素存储在连续的空间中，在deque中通过指针加偏移 量方式访问元素可能会导致非法的操作。 
> 4. vector与list提供了相似的接口，因此其具有类似的用途，但是内部的实现原理不同：vector使用使用了 动态数组，该数组通常需要动态增长；deque中的元素可能分散在不同的存储块中，在deque中保存了 一些必要的信息，通常用来在常数范围内直接访问deque中的任何一个元素，所以deque的内部实现比 vector复杂，但是这些额外信息使得dque在某些情况下增长更加的高效，特别是在序列比较大，重新分 配成本比较高的情况下。 
> 5. 除了在频繁在头部或尾部进行插入和删除操作外，deque比list和forward_list的性能更差。

###  priority_queue 

> 1. 优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的。 
> 2. 此上下文类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素(优先队列中位于顶部的元素)。
>
> 3. 优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特 定的成员函数来访问其元素。元素从特定容器的“尾部”弹出，其称为优先队列的顶部。 
> 4. 底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过随机访问迭 代器访问，并支持以下操作： 
>
> > - empty()：检测容器是否为空 
> > - size()：返回容器中有效元素个数 
> > - front()：返回容器中第一个元素的引用 
> > - push_back()：在容器尾部插入元素 
> > - pop_back()：删除容器尾部元素 
>
> 5. 标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指 定容器类，则使用vector。 
> 6. 需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数 make_heap、push_heap和pop_heap来自动完成此操作。 

> **优先级队列默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成**
>
> **堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。注意：** 
>
> **默认情况下priority_queue是大堆**

### deque的迭代器 

> 双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”的假象，落在了deque的 
>
> 迭代器身上。
>
>  



> 1. stack是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。 
>
> 2. stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。
>
> 3. stack的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下 操作： 
>
>    > - empty：判空操作 
>    > - back：获取尾部元素操作 
>    > - push_back：尾部插入元素操作 
>    > - pop_back：尾部删除元素操作 
>
> 4. 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器， 默认情况下使用deque。 



> #### 用两个栈实现队列：
>
> 1.入队栈：只负责入数据
>
> 2.出队栈：只负责出数据
>
> push：给入队栈push
>
> pop：如果出队栈为空，把入队栈的元素倒过来，出队栈元素如果不为空，直接出栈顶元素
>
> #### 用两个队列实现栈：
>
> 1.始终保持一个队列是空的
>
> 2.入栈时，元素向飞空队列入队
>
> 3.出栈时，元素先导入空队列，出非空的最后一个元素
>
> #### 用两个队列一个二维数组：
>
> 队列1存放接待你
>
> 队列2存在每个结点对应的层号
>
> 1.每一次出队的节点，对应的层号也出队，按照层号放入对应的二位数组的行中
>
> 2.把出队节点的孩子节点入队，对应的汉字节点的层号+1，同样的孩子节点的层号也导入一个队列
>
> 循环1，2
>
> 3.结束：队列为空



### 容器适配器 

##### 适配器：把已有容器转为另一种容器的设计方法，本质上是一种转换

> 适配器是一种设计模式(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总 
>
> 结)，该中模式是将一个类的接口转换成客户希望的另外一个接口。
>
> 虽然stack、queue、priority_queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将 
>
> 其称为**容器适配器**，这是因为每个容器在底层都有自己的实现方式，而stack、queue、priority_queue只是 在底层将其他容器进行了封装。



#### 为什么选择deque作为stack和queue的底层默认容器 ？

> stack是一种后进先出的特殊线性数据结构，因此只要具有push_back()和pop_back()操作的线性结构，都可 
>
> 以作为stack的底层容器，比如vector和list都可以；queue是先进先出的特殊线性数据结构，只要具有 
>
> push_back和pop_front操作的线性结构，都可以作为queue的底层容器，比如list。但是STL中对stack和 
>
> queue默认选择deque作为其底层容器，主要是因为： 
>
> > - stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。 
> > - 在stack中元素增长时，deque比vector的效率高；queue中的元素增长时，deque不仅效率高，而且内 存使用率高。

> stack：可以用list，vector，deque
>
> 默认用queue队列：尾插尾删时间复杂度O（1），增容代价较小，每次只需要开辟新的buffer，如果中控满载，只需要开辟一个更大的区域，把指针数组拷贝，不需要拷贝数据，也不会造成内存碎片
>
> queue:可以用list和queue，迷人是queue，不能用vector实现，vector不提供pop_front接口
>
> priority_queue:可以用vector，deque，默认容器vector，因vector随机访问效率高，它底层的逻辑结构是堆，不能用list实现，在插入和删除的时候，不同通过随即范根的宋史进行元素的调整，无法保证堆的性质