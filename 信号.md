## 信号概念

> 信号是进程之间事件异步通知的一种方式，属于软中断
>
> 信号的作用，相当于神经系统，帮助操作系统来处理运行过程中遇到的各种意外情况

> 信号是一个计数器，负责进行进程间的同步和互斥，整个计数器描述了可用资源的个数
>
> 每次有进程想申请一个可用资源的时候，计数器-1    p；
>
> 每次有进程想释放一个可用资源的时候，计数器+1    V；
>
> 如果计数器已经是0了，这时候再有进程想要申请资源：
>
> 1.进程会挂起等待 ；2.会放弃申请资源

#### `kill -l`命令可以察看系统定义的信号列表

编号34以上的是实时信号





#### 信号的处理方式

> 1.忽略此信号
>
> 2.默认处理行为（大部分信号的默认行为，都是终止进程）
>
> 3.捕捉信号                                   
>
> 
>
> 提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉(Catch)一个信号



#### 信号的特点：

> 1.信号有很多种
>
> 2.不同的信号，会有不同的处理方式
>
> 3.在信号发生之前，每种信号如何处理，我们都是知道的

> 







####  解引用空指针引发的后果有哪些？

> 1.程序崩溃
>
> MMU
>
> 
>
> man 2 kill 系统调用区块的手册，，

#### 共享内存使用步骤：

> 1.创建/打开共享内存对象
>
> 2.附加到共享内存对象上（shmat—>attcah，用法和malloc十分相似）
>
> 3.使用共享内存



> 队列：先进先出
>
> 优先队列：每次列出一个优先级最高的元素
>
> 消息队列（带类型的队列） 每次按照指定类型来处队列
>
> 广义：消息队列也是一个队列，每个元素都带有一个类型出队列的时，是按照指定类型来先进先出的











> cat 不写参数，，默认从标准输入读取数据。。。
>
> pidof cat  //获取制动名字的pid

##### kill的简单实现

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
int main(int argc, char* argv[]){
//为了实现简单，只进行处理一个进程
    if(argc != 3){
        prinyf("参数有误! ./mykill [signo] [pid]\n");
        return 1;
    }
    into signo = atoi(argv[1]+1);
    pid_t pid = atoi(argv[])
    printf("%d\n", signo)；
        return 0;
}
    
```

//c语言字符串转整数

1.atoi

2.sprintf/sscanf

```c
#include <stdio.h>
#include <sstdlib.h>

int main(){
    char str[] = "100";
    int num = atoi(str);
    prinft("%d/n",num);//1
    
    
    
    
    char str[] = "100";//2
    int num = 0;
    sscanf(str,"%d",&num);
    printf("%d/n",num);
}
    
```

c++中的   

1.stringtream

```c++
#include <stdio.h>
#include <sstdlib.h>
#include <unistd.h>
#include <string>

int main（）{
    std::stringstream  ss;
    str::string str = "100";
    int num = 0;
    ss << str;
    ss >> num;
    std::cout << num << std::end1;
    return 0;
}
```

2.std::stoi

```
std:: string str = "100";
int num = std::stoi(str);
std::cout << num << std::end1;

g++   1.cc  -std = c++11
```

boost

```boost
std::string str = "1000";
int num = boost =boost::lexcal_cash<int>
```

siginal



```
void Myhandler(int singno){  //MYhandler 是回调函数  
    
}

//可替换原有的
```



## 产生信号

#### 信号的产生

> 1键盘按键产生  ctrl + c => 2      ctrl + z =>19          ctrl + \  => 3
>
> 2.硬件条件产生  a.MMU产生的信号 —> 11 MMU负责从虚拟地址翻译成物理地址，如果发现虚拟地址非法，MMU硬件设备就会告诉操作系统这个情况。有操作系统给指定进程发送一个11号信号，=>内存访问越界/解引用空指针    b.CPU产生的信号—> 8
>
> 3.软件条件产生   PIPE 读端关闭，尝试写，此时就会触发SUGPIPE信号，管道破裂，TCP中一定的条件下也会出发到SIGPIPE信号
>
> 4.系统调用产生



#### 信号的捕捉流程

> 信号处理函数是一个独立的执行流，和原有的用户代码之间没有相互调用关系（重要）
>
> 信号在处理函数执行过程中，原有的执行流在等待（重要）

## 阻塞信号

有的时候信号不会立刻被处理，而是要等到时机合适再进行处理

## 信号捕捉







操作系统给进程发信号，本质上就是再未决信号集中写一个信号的信息（几号信号）。

标识哪些信号布里克处理，通过一些函数来操作阻塞信号集



同一时刻一个进程收到了大量的2号信号，极有可能只处理一次





一个函数如果再多个执行流中被调用，就可能会出现问题

可重入函数：若一个函数可重入，意味着再多个执行流中调用是没问题的；

不可，有问题

如果一个函数使用了全局变量/静态变量，不可重入；

如果一个函数使用了malloc ，不可重入；

调用了不可重入的函数，也是不可重入的。





#### c语言关键字 volatile

```c
void MyHandler(int sig ){         //  初始的
    
voiatile void MyHandler(int sig ){//加上 voiatile//告诉变量必须每次都从内存中存取，不敢优化到寄存器中
    //功能： 保存内存可见性
    (void)sig;
    flag = 0;   
}
int main()
{
    signal(2,MyHandler);
    while(flag);//把内存中的数据读到CPU中
    return 0;
}

//Makefile  -O2之后，  编译器优化级别
 O0  O1 O2 O3
 //由于 while循环需要频繁读取flag到寄存器中，编译器就会判定这是一个比较高的开销；另一方面，编译器没检测到哪个代码需要修道flag（MyHandler函数是由内核调用的，编译器并不知道），编译器就出现了错误的判断，就直接把flag这个值优化到寄存器中
```

 volatile经常要使用再多线程程序中，编译器对于这种多执行流的情况是不太会判断的

c中原先的auto：表示变量可以自动访问内存



wait 阻塞等待    //代码简单，但是效率低

waitpid 阻塞/非阻塞  //充分利用等待时间做其他事情,效率高·

两全其美：SIGCHLD 17号信号  子进程结束后，父进程会发

```c
void MyHandler(int sig){
    (void)g;
    wait(NULL);
}
int main(){
    signal(17,MyHandler);
    pid_t ret = fork;
    it (ret > o){//father
        
        
    }
        
```

多个信号同时到达，亏能只被处理一次

//非阻塞式轮询可以解决

```c
void MyHandler(int sig){
    (void)sig;
    printf("cgild exit\n");
    while(1)
    {
        //如果ret > 0 已经会受到一个进程了，返回值是子进程的pid
        // = 0    还有子进程再，但是子进程没结束
       // < 0 没u有子进程了
    }
    wait(NULL);
}


signal（SIGCHLD , SIG_IGN） //忽略信号     直接避免子进程僵死进程
```



































