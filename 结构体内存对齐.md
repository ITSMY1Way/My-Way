### 结构体的声明

```c
struct Stu
{
     char name[20];//名字
     int age;//年龄
     char sex[5];//性别
     char id[20];//学号
}；//分号不能丢
    
//特殊的声明
//匿名结构体类型   在声明的时候省略掉了结构体标签（tag）
struct
{
     int a;
     char b;
     float c;   
}x;
struct
{
     int a;
     char b;
     float c;
}a[20], *p;
//自引用方式
struct Node
{
    int data;
    struct Node* next;
};
typedef struct Node
{
    int data;
    struct Node* next; 
}Node;
//结构体变量和初始化
struct Point
{
    int x;
    int y; 
}p1; //声明类型的同时定义变量p1
struct Point p2; //定义结构体变量p2
//初始化：定义变量的同时赋初值。
struct Point p3 = {x, y};
struct Stu        //类型声明
{
    char name[15];//名字
    int age;      //年龄
};
struct Stu s = {"zhangsan", 20};//初始化
struct Node
{
    int data;
    struct Point p;
    struct Node* next; 
}n1 = {10, {4,5}, NULL}; //结构体嵌套初始化
struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化
```

### 结构体内存地对齐



> 1.第一个成员在与结构体偏移量为0的地址处。 
>
> 2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 
>
> 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 
>
> VS中默认的对齐数为8，
>
> Linux gcc没有默认对齐数：参考：https://blog.csdn.net/weixin_42678507/article/details/90109173
>
> 3.结构体总大小为：最大对齐数的整数倍。 
>
> 4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是      所有最大对齐数（含嵌套结构体的对齐数）的整数倍。 

> 在windows(32)/VC6.0下各种类型的变量的自身对齐参数就是该类型变量所占字节数的大小，
>
> 而在linux(32)/GCC下double类型的变量自身对齐参数是4，是因为linux(32)/GCC下如果该类型变量的长度没有超过CPU的字长，则以该类型变量的长度作为自身对齐参数，如果该类型变量的长度超过CPU字长，则自身对齐参数为CPU字长，而32位系统其CPU字长是4，所以linux(32)/GCC下double类型的变量自身对齐参数是4，如果是在Linux(64)下，则double类型的自身对齐参数是8。
>
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805133646129.png)
>
> 　　除了变量的自身对齐参数外，还有一个对齐参数，就是每个编译器默认的对齐参数#pragma pack(n)，这个值可以通过代码去设定，如果没有设定，则取系统的默认值。在windows(32)/VC6.0下，n的取值可以为1、2、4、8，默认情况下为8。注意像DEV-CPP、MinGW等在windows下n的取值和VC的相同。  

```c
//vs2013     #pragma pack(8)
struct S1
    {
        char c1;//1
        int i;//1xxx  1111
        short s2;//1xxx 1111  11xx
    };//结构体大小是10字节
    printf("%d\n", sizeof(struct S1));//整体对齐数是12
    struct S2
    {
        char c1;
        short s2;
        int i;
    };
    printf("%d\n", sizeof(struct S2));//8
struct s3
{
    int a;
    short b;
    static int c;//结构体中包含静态数据成员，而静态数据成员的存放位置与结构体实例的存储地址无关(只有在C++中结构体中才能含有静态数据成员)
                 //变量c是单独存放在静态数据区的，因此用siezof计算其大小时没有将c所占的空间计算进来
};//8
struct s4
{
    bool a;
    S1 s1;
    double b;
    int c;//1+3+8+4+8+4=28字节。
};//对于整个结构体来说，各个变量的最终对齐参数为1，4，8，4，最大值为8，#pragma pack(n)默认值为8，所以最终结构体的大小必须是8的倍数，因此需要在最后面填充4字节达到32字节
   //|--------bool--------|    4字节
 　//|---------s1---------|    8字节
 　//|--------------------|     4字节
 　//|--------double------|    8字节
 　//|----int----|---------|     8字节 
```

####  为什么要进行内存对齐?

> 1. 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址 处取某些特定类型的数据，否则抛出硬件异常。 
> 2. 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理 器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
>
>  结构体的内存对齐是拿空间来换取时间的做法。 
>
> 在设计结构体的时候，我们既要满足对齐，又要节省空间。 应该：让占用空间小的成员尽量集中在一起

#### **如何让结构体按照指定的对齐参数进行对齐?** 

```c
//使用预处理命令 #pragma
#include <stdio.h>
#pragma pack(8)//设置默认对齐数为8
struct S1
{
    char c1;
    int i;
    char c2;
};
#pragma pack()//取消设置的默认对齐数，还原为默认
```

#### **如何知道结构体中某个成员相对于结构体起始位置的偏移量?** 

```cpp
#include<iostream>
using namespace std;
#define offsetof(s,m) (size_t) &(((s*)0)->m)
struct N
{	int i;	
    char j;	
    double k; 
};
int main()
{	
    cout<<offsetof(N,j)<<endl;	
    return 0;
}//（s*）0:是骗编译器说有一个指向类（或者结构体）s的指针，它的值是0. 
//&（（（s*）0）->m）这个是取结构体中s的成员m,由于这个类的基址是0,这时m的地址就是在结构体中的偏移地址
```



类型所能标识的值的范围决定了转换的过程：

> - 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
> - 赋给带符号类型一个超出它表示的范围的值时，结果是未定义的，此时，程序可能继续关注，可能膨崩溃，也可能产生数据垃圾 
>

### 取余取模运算

> 对于整型数a，b来说，取模运算或者求余运算的方法都是：
>
> 1.求 整数商： c = a/b;
>
> 2.计算模或者余数： r = a - c*b.
>
> 求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。
>
> 例如计算：-7 Mod 4
>
> 那么：a = -7；b = 4；
>
> 第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；
>
> 第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。
>
> 归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。
>
> 当符号不一致时，结果不一样。商为负数。
>
> 另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。
>
> 补充：
>
> 7 mod 4 = 3（商 = 1 或 2，1<2，取商=1）
>
> -7 mod 4 = 1（商 = -1 或 -2，-2<-1，取商=-2）
>
> 7 mod -4 = -1（商 = -1或-2，-2<-1，取商=-2）
>
> -7 mod -4 = -3（商 = 1或2，1<2，取商=1）
>
> 这里模是4，取模其实全称应该是取模数的余数，或取模余。
> 
> 取模运算时,对于负数,应该加上被除数的整数倍,使结果大于或等于0之后,再进行运算.
对于上例:
-1+256=255,然后用255%256,结果就是255.
当然也可以-1+512=511,511%256的结果也是255.




> 以0开始投的整数代表八进制数
>
> 以0x / 0X开头的代表十六进制数
>
> 十进制就是正常的

"A" 字符串代表了一个字符的数组，该数组还包含空字符'\0'

‘A’字面值表示的就是单独的字符A

如果\后面跟着的八进制数字超过3个，只要前三个数字与\构成转义序列。

理解r的类型是声明，最简单的办法是从右向左阅读r的定义。

离变量名最近的符号对变量的类型有最直接的影响。

临时量对象——当编译器需要一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。
