## 1.类的访问限定符及封装 

### 1.1访问限定符

> C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其 
>
> 接口提供给外部的用户使用。
>
> **【访问限定符说明】**
>
> > 1. public修饰的成员在类外可以直接被访问 
> > 2. protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的) 
> > 3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 
> > 4. class的默认访问权限为private，struct为public(因为struct要兼容C) 
> >
> > 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别
>
> **C++中struct和class的区别是什么？** 
>
> 答：C++需要兼容C语言，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。 
>
> 和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是struct的成员默认访问方式 
>
> 是private。

### 1.2封装

> 面向对象的三大特性：**封装、继承、多态**。 
>
> 在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？ 
>
> **封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行** 
>
> **交互。** 
>

### 2.this指针

> C++中通过引入this指针解决该问题，即：C++编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指 
>
> 针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访 
>
> 问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。
>
> 特征：
>
> > 1. this指针的类型：类类型* const 
> > 2. 只能在“成员函数”的内部使用 
> > 3. this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。 
> > 4. this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户 传递
>
> - **this指针存在哪里？** 
>
>   其实编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中(VC++编译器是放在ECX中，其它编译器有可能不同)。也就是成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在寄存器中。类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量。
>
>   原文：https://blog.csdn.net/M_jianjianjiao/article/details/83419219 
>
> - **this指针可以为空吗？**
>
>   可以为空，当我们在调用函数的时候，如果函数内部并不需要使用到this,也就是不需要通过this指向当前对象并对其进行操作时才可以为空(当我们在其中什么都不放或者在里面随便打印一个字符串)，如果调用的函数需要指向当前对象，并进行操作，则会发生错误（空指针引用）就跟C中一样不能进行空指针的引用。原文：https://blog.csdn.net/M_jianjianjiao/article/details/83419219 

### 3.对象

> 对象是指一块能村粗数据并具有某种类型的内存空间
>
> 初始化≠赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
>
> 变量可被定义一次，单多次声明，
>
> C++支持分离式编译：声明使得名字为程序所知，而定义负责创建与名字关联的实体。4

> `it->empty()`  箭头运算符将解引用和成员访问两个操作结合在一起，他的作用和`(*it).empty()`相同。

