

## 一、什么是指针？

> *是           取指针目标运算符 
>
> 指针变量名与内存位置之间的关联由编译器实现，硬件可通过地址访问内存位置
>
> 指针是有类型的，指针的类型决定了指针的+-整数的步长，指针解引用操作的权限。
>
> -  指针就是地址，地址就是指针；指针变量是一个变量，它保存了基本类型变量的地址。
> - 如果指针变量p保存了变量a的地址，那么称作p指向了a，*p 就是变量a。
> - 如果p是一个指针变量，*p 表示了以 p 的内容为地址的变量，就是p指向的变量。
>
> 地址就是可以唯一标识某一点的一个编号，即一个数字,通过地址运算符"&"得到变量的地址。
>
> 变量相当于是一个容器，用来存放数据的，变量是存放在内存中的。在C++ 中定义变量的形式是： 数据类型 + 变量名，这里的变量名实际上是一个符号地址，在程序编译时，操作系统将为每个变量在内存中分配内存，所以每个变量都有一个在内存中的地址，即物理地址。并将变量的符号地址（变量名）和物理地址关联起来，所以，我们在程序中对变量名的操作，编译时编译器都会将变量名转换为变量在内存中的物理地址，从而实现了对内存中指定地址区域的数据的操作，这就是变量的实现原理。**变量在内存中的地址又称作指针，我们说“变量的地址” 就等价于 “变量的指针”，但是指针和指针变量是不一样的。**
>
> 指针是编程语言中的一个对象，利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。**变量在内存中的地址又称作指针，我们说“变量的地址” 就等价于 “变量的指针”，但是指针和指针变量是不一样的。**
>
> **指针变量**用来存放普通变量的地址，即指针变量是用来存放普通变量的指针。指针变量也是一个变量，在内存中也是占内存的，只不过它不存放基本类型数据，而是存放其他基本类型变量的地址。那指针变量也有物理地址，比该指针类型高一级的指针变量来存放指针变量的地址，如二级指针变量存放一级指针变量的地址。
>
> 变量的指针就是变量的地址。 存放变量地址的变量是指针变量。  允许用一个变量来存放指针，这种变量称为指针变量。 因此，一个指针变量的值就是某个变量的地址或称为某变量的指针 
>
> -   比如:  int a;//变量 
> -  int *p;//指针变量  
> - p=&a;//p就是变量a的指针,你可以叫它变量指针

> ​                    int a ;  //定义int类型变量
>
> ​                    int *p = &a;   //变量 p 是一个 int* 类型的一级指针变量，&是取地址符，p保存了a 的地址
>
> ​                    cout << *p <<endl; //输出 p 指向变量的值，即输出a的值
>
> ​		    cout <<  p << endl; //输出 p 的值，即输出变量a在内存中的地址
>
> ​                    int **q;  //定义二级指针变量
>
> ​                    q = &p; // 二级指针变量q保存了一级指针变量p的地址
>
> ​                    cout << q <<endl; //输出指针变量p在内存中的地址
>
> ​		    cout <<  *q << endl; //输出q指向变量的值，即变量p的值，即a的地址
>
> ​                    cout <<  **q << endl; //可以这样理解  cout<<*(*q), 等价于 cout <<*p， 即输出a的值

（存放在指针中的值都被当成**地址**处理）                           

 指针是（地址）≠指针变量（是变量）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

> main 函数内的变量不是全局变量，而是局部变量，只不过它的生命周期和全局变量一样长而已。
>
> 全局变量一定是定义在函数外部的

声明一个指针变量并不会自动分配任何内存，在对指针执行间接访问前，指针必须进行**初始化**，或者使它**指向现有的内存**，或者给它**分配动态内存**

将数值存储到指定的内存地址 ——  往内存0x12ff7c 地址上存入一个整数0x100 

```c
int * p=（int *）0x12ff7c
*p=0x100；//即*（int *）0x12ff7c = 0x100；
```

* #### 指针的大小

指针的大小是固定的**4/8**个字节（32位平台/64位平台）

* #### 间接访问操作符  *

*void不可以定义变量。因为定义变量前提要开辟空间，而void是空类型。*

*void*可以，但void *定义的变量不可被解引用。*  

通过一个指针访问它所指向的地址的过程称为**间接访问**或**解引用指针**。

## 二、指针的运算

* #### 对指针进行加 1 操作

  得到的是下一个**元素**的地址，而不是原有地址值直接加 1。所以，一个类型为 T 的指针的移动，以 sizeof(T) 为移动单位。

  | **一级指针** | 加上指向其类型的大小 |
  | ------------ | -------------------- |
  | **多级指针** | **直接+4**           |

* #### 指针± 整数

  只能用于数组中**指向某个元素的指针**

  标准规定：

  > 允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一 个元素之前的那个内存位置的指针进行比较。

  若结果所指向的位置在数组第1个元素之前或在最后1个之后，其效果是**未定义**的。

  如果      **—**      操作后结果产生的指针所指向的位置在数组第一个元素之前，那么它是**非法**的。

  

  让指针指向数组最后1个元素后面的那个位置是**合法**的，但对这个指针执行间接访问可能会**失败**。

  对于       **+**       结果指针指向数组最后一个元素后面的哪个内存地址仍然**合法**（但不能对这个指针执行间接访问操作，不过再**往后不合法了**。

* #### 指针-指针

  只有当两个指针都**指向同一个数组中的元素**时，才允许从一个指针减去另一个指针。

  结果是两个指针在内存中的距离（以**数组元素的长度**为单位）。

  若p1指向 `array[i]`                   p2指向 `array[j]`

  则 p2-p1     就是              j-i      的值

  p1-p2 是**合法**的是           i-j      的值

  若两指针指向的不是同一个数组中的元素，我们不知道两个数组在**内存中的相对位置**，两个指针之间的距离就没有意义。   

* #### 指针的关系运算

  **<           <=                           >           >=**

  前提是指向同一数组中的元素

## 三、指针常量

指针常量的本质是一个**常量**，并且使用指针来修饰它，那么说明这个常量的值应该是一个指针

其格式为：  `int const * p`或者 `const int* p`

声明：

```c
int a;
int *const p = &a; 
```

*（指针）和 const（常量） 谁在前先读谁 ； *象征着地址，const象征着内容；谁在前面谁就不允许改变。

间接访问操作只能作用于指针类型表达式，若要把25存储于位置100必须要**强制类型转换**。

`*(int *)100 = 25;`

## 四、二级指针

`char **p;`
定义了一个二级指针变量 p。p 是一个指针变量，在 32 位系统下占 **4 个 byte**。 

与一级指针不同的是，一级指针保存的是**数据的地址**，二级指针保存的是**一级指针的地址**。

*ppa 通过对ppa中的地址进行解引用，这样找到的是 pa ， *ppa 其实访问的就是 pa .

**ppa 先通过 *ppa 找到 pa ,然后对 pa 进行解引用操作： *pa ，那找到的是 a .

```c
int a = 12;
int *b = &a;
int **c = &b;
```

​                                                                       **双重间接访问**

| 表达式 | 相当的表达式 |
| ------ | ------------ |
| a      | 12           |
| b      | &a           |
| *b     | a,12         |
| c      | &b           |
| *c     | b,&a         |
| **c    | *b,a,12      |

##  五、NULL指针

表示**不指向任何东西**，要使一个指针变量为NULL，可以给它赋一个0值；

为了测试一个指针变量是否为NULL，可以将它与0进行比较；

<!--对一个NULL指针进行解引用是非法的-->

所以,**在对指针进行解引用之前，确保它并非NULL指针**

它被宏定义为 0：    `#define NULL 0`

`*&a = 25；`**把值25赋给a**。&产生变量a的地址。它是一个指针常量，接着*访问其操作数所表示的地址。

## 六、函数指针

函数指针是**指向函数的指针变量**。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向地址。有了指向函数的指针变量后，可用该指针变量调用函数

函数指针有两个用途：**调用函数**和**做函数的参数**。

```c
int func (int x);       /*声明一个函数 */
int (* f) (int x);      /*声明一个函数指针 */
f=func;                 /*将func函数的首地址赋给指针f */
```

或者使用下面的方法将函数地址赋给函数指针：

```c
 f = &func;
```

## 七、数组指针和指针数组

**指针数组** （储存指针的数组） 是**数组**，数组的元素都是指针，数组占多少字节由数组本身决定。

**数组指针** （指向数组的指针） 是**指针**  它指向一个数组，在32位系统下占4字节。

 `int (*  p）[10]`p先和 * 结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针,指向一个数组，叫**数组指针** 。储存储在哪里，我们并不知道。

<u>[]的优先级要高于 * 号的，所以必须加上（）来保证p先和 * 结合。</u>

`int *p[10];`

p 先与“[]”结合，构成一个数组的定义，数组名为 p1，int* 修饰的是数组的内容，即数组的每个元素。这是一个数组，其包含 10 个 指向 int 类型数据的指针，即**指针数组**。

## 八、a与 &a 

##### **&a[0] 和&a[]** (**a与 &a**)

a[0]是一个元素 a[]是整个数组  虽然他们的值一样，但意义不一样 

前者是**数组首元素的首地址**，后者是**数组的首地址**。

同理，a与 &a的值是一样的，但意义不同，前者是数组首元素的首地址，后者是数组的首地址。

## 九、数组名a作左右值区别

> 简单而言，出现在赋值符“=”右边的就是右值，出现在赋值符“=”左边的就是左值。 比如,x=y。

* a 作为右值时其意义与&a[0]是一样，代表的是数组首元素的首地址；

* **a 不能作为左值！**编译器会认为数组名作为左值代表的意思是a的首元素的首地址但是这个地址开始的一块内存是一个总体我们只能访问数组的某个元素而无法把数组当一个总体进行访问。

  所以我们可以把 a[i]当左值，而无法把 a 当左值。

## 十、函数指针数组

`char* (*pf[3])(char *p)` 定义的是一个**函数指针数组**，数组内储存了3给指向函数的指针。这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。

函数指针数组就是数组里面存放的为指向函数的指针。

函数指针数组的用途：转移表   例子：计算器

```c
include <stdio.h>
include <string.h>
char* fun1(char* p)
{
printf("%s\n",p);
return p;
}
char* fun2(char* p)
{
printf("%s\n",p);
return p;
}
char* fun3(char* p)
{
printf("%s\n",p);
return p;
}
int main()
{
char* (*pf[3])(char* p);
pf[0]= fun1; // 可以直接用函数名
pf[1]= &fun2; // 可以用函数名加上取地址符
pf[2]= &fun3;
pf[0]("fun1");
pf[0]("fun2");
pf[0]("fun3");
return 0;
}
```

## 十一、指向函数指针数组的指针

`char* (* ( * pf)[3])(char* p);`

这个指针指向一个包含了 3 个元素的数组；这个数字里面存的是指向函数的指针；这些指针指向一些返回值类型为指向字符的指针、参数为一个 指向字符的指针的函数

指向函数指针数组的指针是一个 **指针** 指针指向一个 **数组** ，数组的元素都是 **函数指针** ;

```c
include <stdio.h>
include <string.h>
char* fun1(char* p)
{
printf("%s\n",p);
return p;
}
char* fun2(char* p)
{
printf("%s\n",p);
return p;
}
char* fun3(char* p)
{
printf("%s\n",p);
return p;
}
int main()
{
char* (*a[3])(char* p);
char* (*(*pf)[3])(char* p);
pf = &a;
a[0]= fun1;
a[1]= &fun2;
a[2]= &fun3;
pf[0][0]("fun1");
pf[0][1]("fun2");
pf[0][2]("fun3");
return 0;
}


void test(const char* str) {
printf("%s\n", str);
}
int main()
{
//函数指针pfun
void (*pfun)(const char*) = test;
//函数指针的数组pfunArr
void (*pfunArr[5])(const char* str);
pfunArr[0] = test;
//指向函数指针数组pfunArr的指针ppfunArr
void (*(*ppfunArr)[10])(const char*) = &pfunArr;
return 0;
}
```

## 十二、指针和数组的对比

| 指针                                                         | 数组                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 保存数据的地址，任何存入指针变量 p 的数 据都会被当作地址来处理。p 本身的地址由 编译器另外存储，存储在哪里，我们并不知道 | 保存数据，数组名 a 代表的是数组首元素的 首地址而不是数组的首地址。&a 才是整个数 组的首地址。a 本身的地址由编译器另外存储，存储在哪里，我们并不知道。 |
| 间接访问数据，首先取得指针变量 p 的内容， 把它作为地址，然后从这个地址提取数据或 向这个地址写入数据。指针可以以指针的形 式访问* (p+i)；也可以以下标的形式访问 p[i]。 但其本质都是先取 p 的内容然后加上 i*sizeof(类型)个 byte 作为数据的真正地址 | 直接访问数据，数组名 a 是整个数组的名字， 数组内每个元素并没有名字。只能通过“具 名+匿名”的方式来访问其某个元素，不能把 数组当一个整体来进行读写操作。数组可以 以指针的形式访问* (a+i)；也可以以下标的形 式访问 a[i]。但其本质都是 a 所代表的数组首 元素的首地址加上 i*sizeof(类型)个byte作为 数据的真正地址。 |
| 通常用于动态数据结构                                         | 通常用于存储固定数目且数据类型相同的元素                     |
| 相关的函数为 malloc 和 free                                  | 隐式分配和删除                                               |
| 通常指向匿名数据（当然也可指向具名数据）                     | 自身即为数组名                                               |

## 十三、数组参数与指针参数

- #### 一维数组参数与一维指针参数

  > C 语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针;
  >
  > 当数组超过一维时，将第一维改写为指向数组首元素首地址的指针之后，后面的维度再也不可改写。
  >
  > 比如：`a[3][4][5]`作为参数时可以被改写为`(*p)[4][5]` 。
  >
  > C 语言中，所有非数组形式的数据实参均以传值形式（对实参做一份拷贝并传递给被调用的函数，函数不能修改作为实参的实际变量的值，而只能修改 传递给它的那份拷贝）调用
  >
  > 函数本身是没有类型的，只有函数的返回值才有

  数组传参时 降为 **指向其内部元素类型的指针**

  * **一维数组参数**

    <u>无法向函数传递一个数组</u>

    ```c
    void fun(char a[]) {
    charc = a[3];
    }
    int main()
    {
    char b[100]= “abcdefg”;
    fun(b);
    return 0;
    }
    ```

  * **一级指针参数**

    <u>无法把指针变量本身传递给一个函数</u>

    ```c
    char* GetMemory（char* p,int num）
    {
    p = (char*)malloc(num*sizeof(char));
    return p；
    }
    int main()
    {
    char*str= NULL;
    str= GetMemory（str，10）;
    strcpy(str,”hello”);
    free（str）；
    return 0;
    }
    ```

    ```c
    void GetMemory（char** p,int num）
    {
    *p = (char*)malloc(num*sizeof(char));
    return p；
    }
    int main()
    {
    char*str= NULL;
    GetMemory（&str，10）;
    strcpy(str,”hello”);
    free（str）；
    return 0;
    }
    ```

- #### 二维数组参数与二维指针参数

  `void fun（char (*p)[4];`

  `void fun（char a [][4] ;` 

​      二维数组传参，函数形参的设计只能省略第一个[]的数字。

* ####  二维数组的地址

  `int a[5][5]; `

   `int (*p)[4]; `

  a 在这里代表的是 a[0]的首地址。a+1 表示的是一维数组 a 的第二个元素。

  a[4]表示的是一维数组 a 的第 5 个元素，而这个元素里又存了一个一维数组。

  所以`&a[4][2]`表示的 是`&a[0][0]`+4* 5 * sizeof(int)+2*sizeof(int)

  p[4]相对于 p[0]来说是向后移动了 4 个“包含 4 个 int 类型元素的数组”
   即&p[4]表示的是&p[0]+4 * 4 * sizeof(int)。由于 p 被初始化为&a[0]，

  那么`&p[4][2]`表示的是 `&a[0][0]`+4 * 4 * sizeof(int)+2* sizeof(int)。

  `a [ i ][ j ]`的**首地址**是a+i*sizeof(类型) * j(总)+j*sizeof(类型) 

  即     ***( *(a+i)+j)**

* #### 二维数组参数和二维指针参数的等效关系

| 数组参数                  | 等效的指针参数            |
| ------------------------- | ------------------------- |
| 数组的数组：char a [3][4] | 数组的指针：char (*p)[10] |
| 指针数组： char *a[5]     | 指针的指针：char **p      |

##                                             练习

```c
struct Test
{
    int Num;
    char *pcName;
    short sDate;
    char cha[2];
    short sBa[4];
}*p;
//假设p 的值为0x100000。 如下表表达式的值分别为多少？
p + 0x1 = 0x___ ? 
// p 是一个结构体指针，p+1实际上是要加上p所指向的类型的大小，而p指向的这个结构体的大小是20字节，所以
      //0x100014
(unsigned long)p + 0x1 = 0x___ ? 
//把p强转成 unsigned long 类型，那这里就是一个无符号长整型数字加1，所以   0x100001
(unsigned int*)p + 0x1 = 0x___ ?
//把p强转成 unsigned int * 类型，此时p就是一个指针，指针加一就是加上它所指向的类型的大小，无符号长整型数据的大小是4，所以    0x100004。
```

```c
int main()
{
	int a[4] = { 1, 2, 3, 4 };
	int *ptr1 = (int *)(&a + 1);
	int *ptr2 = (int *)((int)a + 1);
	printf("%x, %x", ptr1[-1], *ptr2);
	getchar();
	return 0;
}
// ptr1[-1] ： int *ptr1 = (int *)(&a + 1); 这行代码中 &a 代表整个数组的地址，(&a + 1) 就代表数组a下一个int类型数字的地址，把这个地址强转成 int * 赋给ptr，ptr 就指向尾元素a[3]下个元素的地址。ptr1[-1] 就相当于 *(ptr - 1)。所以最后结果是：0x000004。
//p2：(int)a + 1表示把a强转成整型数据，再加1则(int)a + 1就是元素a[0]的第二个字节的地址，然后再把这个地址强转为int * 类型赋值给p2，那*p2的值就是从元素a[0]的第二个字节开始的连续4字节的内容。 
  //那么这连续4个字节内容是什么呢？这里就要区分大小端了，小端模式返回0x2000000；大端模式返回0x100。 
```



```c
#include <stdio.h>
int main(int argc, char * argv[])
{
    int a[3][2] = { (0, 1), (2, 3), (4, 5) };
    int *p; p = a[0];
    printf( "%d", p[0]);
}
//花括号里面是圆括号，所以这里就组成了逗号表达式。最后数组里面的值是 a[3][2] = {1, 3, 5, 0, 0, 0}; 
    //所以a[0] = 1。
```

```C
int main()
{
    int a[5][5];
    int(*p)[4];
    p = a;
    printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
    system("pause");
    return 0;
}
//FFFFFFFC 和 -4
```



```c
int main()
{
    int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int *ptr1 = (int *)(&aa + 1);
    int *ptr2 = (int *)(*(aa + 1));
    printf("%d, %d", *(ptr1 - 1), *(ptr2 - 1));
    system("pause");
    return 0;
}
//* (ptr1 - 1)：int *ptr1 = (int *)(&aa + 1);这行代码中 &aa 代表整个数组的地址，(&aa + 1) 就代表数组a下一个int类型数字的地址，把这个地址强转成 int * 赋给ptr，这个时候ptr就指向数组 aa 尾元素 aa[2][5] 的下一个元素。然后(ptr1 - 1)，此时 ptr 就指向aa[2][5]。*(ptr1 - 1) = 10。
// *(ptr2 - 1)：int *ptr2 = (int *)(*(aa + 1));这行代码里 aa 代表数组首元素地址，而我们通常解决这类问题时： 把一个二维数组看做一个一维数组，这个一维数组的每个元素都是一个一维数组 ;那aa就代表二维数组里第一行的地址，(aa + 1)代表第二行的地址。* (aa + 1)表示整个第二行，而此时 (aa + 1) 做左值就表示第二行的地址，所以  (ptr2 - 1) = 5。
```

```c
int main()
{
    char *a[] = { "work", "at", "alibaba" };
    char **pa = a;
    pa++;
    printf("%s\n", *pa);

    system("pause");
    return 0;
}
//char **pa = a;此时pa是一个二级指针，pa++;实际上是pa加上它所指向的元素类型的大小，而pa指向的是一个 char * 类型指针，即pa = &a[0]，pa++之后，pa = &a[1]。所以*pa = a[1]，最后输出结果就是 “at” 。
```

```c
int main()
{
    char *c[]={"ENTER","NEW","POINT","FIRST"};
    char **cp[]={c+3,c+2,c+1,c};
    char ***cpp=cp;
    printf("%s\n",**++cpp);//POINT
    printf("%s\n",*--*++cpp+3);//ER
    printf("%s\n",*cpp[-2]+3);//ST
    printf("%s\n",cpp[-1][-1]+1);//EW
    return 0;
}
```

参考链接：https://blog.csdn.net/w_y_x_y/article/details/78572236

```c
（1）(*( void(*) ()) 0)()
//void(*)() 是一个函数指针类型，这个函数无参数，无返回值。  
// (void(*)())0 把0强转成函数指针类型，0是一个函数的首地址。  
//(*(void(*)())0) 解引用，把地址为0的函数取出来。  
//(*(void(*)())0)()调用这个地址为0的函数。
（2）void(*signal(int, void(*)(int)))(int);
// 对这块代码进行简化：typedef void(* pfun_t)(int); 
// pfun_t signal(int, pfun_t):定义了一个函数指针 signal，指向的函数有两个参数，类型分别是 int 和 pfun_t 。 
```

## 十四、回调函数

> 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当 这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调 用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 
>
> 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。

## 十五、地



